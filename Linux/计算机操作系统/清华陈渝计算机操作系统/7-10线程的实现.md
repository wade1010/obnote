![](https://gitee.com/hxc8/images8/raw/master/img/202407191126030.jpg)

用户线程：操作系统看不到的线程叫做用户线程。

内核线程：是由操作系统管理起来的线程叫做内核线程。

用户线程操作系统看不到是由谁来管理呢？是由应用程序的库来进行实现，有专门的用户线程库来完成线程管理，

但是内核线程是由操作系统本身来完成线程管理。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191126539.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191126963.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191126473.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191126113.jpg)

上图是用户线程实现，用户态的库完成了对线程控制的管理，整个线程控制的管理。他这个所谓的TCB（线程管理控制块）是在库里面实现的，对于操作系统而言，它看不到这个TCB，它只能看到进程，就是整个进程的信息，操作系统可以看到，但是进程里面的线程信息，是由线程管理库来实现的，这个线程信息操作系统看不到，所以说整个线程的调度和管理，操作系统不直接参与，而是由线程库来完成。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191126020.jpg)

- 由于操作系统无法感知到用户线程的存在，所以呢操作系统只能看到线程所属的进程，所以操作系统不能直接参与线程调度， 如果进程被操作系统设置为等待状态，那么这个进程所包含的线程都不能被执行，

- 每个进程都需要它自己私有的线程控制块（TCB）列表，这个信息全部是由用户态线程库来完成的，它来负责保存、切换。

- 既然是由库来完成的，这个库可以有自己的线程调度算法。这些调度算法、库的管理都是操作系统感知不到的。 

![](https://gitee.com/hxc8/images8/raw/master/img/202407191126686.jpg)

缺点：

前面提到过如果进程执行一个阻塞型的系统调用，什么叫阻塞性系统调用？比如说读文件，读文件它可能时间很长，可能阻塞，就可以把进程给挂起。如果用户线程使用了这么一个系统调用的话，会出现整个进程都在等待，就是说即使其它线程没有发出这种阻塞型系统调用，它们也会被置为等待，为什么？其实已经讲到，因为操作系统感知不到线程，它只能看到进程，只能看到线程所属的进程，从而把这个进程做阻塞，j既然把这个进程做阻塞之后呢，所有属于这个进程的线程也都会被阻塞，所以说整个进程都会停下来。

当一个用户线程开始执行之后，除非它主动的交出CPU使用权，如果它不主动交出，他说在的进程的其它线程没法执行，因为用户态的线程库，它没法主动打断当前用户线程的执行，他没有这个特权，但是我们操作系统有，因为操作系统会管理中断，一旦产生中断呢，控制权就落到了操作系统手里了，操作系统可以对这个中断进一步处理，特别是时钟中断，有了时钟中断之后，操作系统可以完成一个强制的切换，来把线程停止下来，切到其它程序去执行，但是如果说线程的管理库实际上是用户态的话，他没有这个能力，所以说用户线程不主动释放CPU的使用权，该进程中其它线程页无法运行。

由于时间片是分配给进程，在多线程执行时，每个线程得到的时间片相对来说更少些，执行较慢。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191126286.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191127148.jpg)

 

![](https://gitee.com/hxc8/images8/raw/master/img/202407191127580.jpg)
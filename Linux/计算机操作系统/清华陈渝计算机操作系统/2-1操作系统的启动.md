![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE17c6e26d0e85bf4c217bf19c2e1d6c10截图.png)

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE12b0bcfdf1d572bd3840295fc5c7b5dc截图.png)

启动：

启动之后，从计算机原理角度来看，最基本的就是三部分，CPU 内存 IO，那其实操作系统一开放的时候并没有放到内存里给我们CPU去执行的，他其实是放在我们的disk，放在我们硬盘上面的，然后有我们的BIOS来提供相应的支持。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE2b150025612fcbc3207e2f08526e619b截图.png)

BIOS是什么？

全称 基本IO处理系统，这个处理系统的主要功能是说，一按电源，让计算机开机之后就能够开始检测各种各样的外设， 这是BIOS完成的基本功能，检测玩外设之后呢，才能让它去加载相应的软件来进行执行。

OS是放在disk上面的，除了OS之外呢，还有个很简单的小程序叫bootloader，主要功能是来负责加载OS的，能让OS从硬盘放到内存里面去，让CPU可以执行操作系统。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE505472a6cfe9a0d81200fb48aaf548d7截图.png)

在整个计算机内存里面，有一部分空间是BIOS已经占满了，还有很多地方是空的，实际上我们的BIOS第一步要干的事情是从一个特定地址开始执行，这个地址，如果以X86为例的话，这个地址是一个固定的地址，在0xf000:fff0，分别代表CS：IP这两个寄存器的值，CS叫段寄存器，IP是叫指令寄存器，这两个寄存器合在一起可以形成一个具体的内存地址。一开始加点，那我们在这个，BIOS从这个地址开始执行，这个地址执行之后，它会完成接下来一系列的工作，包括自检，自检的意思就是，检查自身各种各样的设备是否能够正常工作。那计算机有哪些基础设备呢？屏幕 键盘 鼠标 硬盘等等，这些最基本的设备都是要由BIOS来进行初始化检查。 假设检查都没问题，接下来就是要把bootloader从硬盘上放到内存中。这是BIOS要完成的最基本的一些功能。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE7f111f3d2f14e3337bd9181f548fd87e截图.png)

BIOS是如何把BootLoader放到内存中的，如上图。BootLoader是放在硬盘上的，放在硬盘的什么地方呢？这一点其实也是很特殊的设置，BootLoader一般是放在硬盘第一个主引导扇区，这样的话BIOS就很容易找，只要找到硬盘的第一个扇区，就可以把它加载到内存中去。 

一般我们硬盘的一个扇区是512个字节，意味这BootLoader不到512个字节，就可以完成很多有趣的功能，其中最主要的功能就是接下来要把一个更复杂的软件从我们的硬盘中给放到我们的内存中， 这是BIOS加载BootLoader，BootLoader再加载IO的大致过程。

以X86为例，BootLoader会放在内存的什么位置呢？这也是由BIOS设定好的，比如放在0x7C00这个地址，从这个地址往上连续512个字节就是BootLoader的代码和数据，这么小的代码和数据，其实完成的功能也是很有限，只是完成了接下来的操作系统的代码和数据从硬盘中加载到内存中去，

上图可以看出BIOS把BootLoader加载到内存中去之后呢，CPU的控制权就由BootLoader来掌控了。BootLoader接下来第一步要干的就是去找到硬盘的起始扇区以及硬盘操作系统的起始扇区以及操作系统的长度。然后把这一块区域，可能包含几个硬盘磁盘块，把磁盘块从硬盘中读到我们内存中，这是BootLoader完成的最主要工作。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE1772ad27a4f8a798f446f37f2d9fdba6截图.png)

读到内存之后，按道理它的工作就完成了， 

工作完成之后，它会把我们这个CPU控制权交给我们的OS，实际上是跳到OS的起始地址去执行。这样我们OS就可以在内存中进行它所必要的工作。从前期的初始化工作到后期能够创建各种各样的应用程序并运行，到这个阶段实际上所有的管理，计算机硬件的管理，都已经处于OS的管理之下了。

上图，不把OS放在BIOS下面的原因，我们BootLoader通常是占用非常小的空间，其中一个原因是，我们不知道OS有多大，会不会覆盖到BIOS本身，所以可以放在下面，同时根据“把code放在最下面，从下往上放”的概念。

#### 操作系统与设备和程序交互

接下来介绍当操作系统正常工作之后呢，如何与我们的外设、应用程序打交道。这里面实际上是有interface的设计问题，那操作系统的interface是什么呢？在我们看来，操作系统的interface就包含3个：

它面向外设是通过中断和IO来进行处理，

面向应用程序是通过系统调用和异常来提供相应的功能。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE5736cac2a681684686c6aa7422814b96截图.png)

系统调用就是应用程序先操作系统发出一个服务的一个请求，希望我们操作系统能够提供相应的支持，发出一个所谓的systemcall就是服务请求，这个systemcall是由我们的应用程序主动，向我们OS提出来的请求，所以说呢，一个系统调用，是由我们应用程序主动向操作系统发送一条特殊的指令，操作这些指令让操作系统完成相应的功能，这叫系统调用。

异常和系统调用不一样，异常也是由我们应用程序产生的，但是呢，它不是应用程序主动想产生的，这个异常其实是应用程序在执行过程中，出现了一些意想不到的事情，使得不得不由我们的操作系统来完成相应的功能。

中断和前两者不一样，前两者来源于我们应用程序，中断是来源于我们外设，这个外设是希望有些特殊事情，需要操作系统去提供相应的支持，这个时候通过中断机制，让操作系统感知到有外设来发出请求了，需要处理了，这个过程称之为中断。

那我们应用程序为什么不能直接访问外设呢？为什么非要通过操作系统？其实我们在一开始给大家提到过，操作系统是特殊的一种软件，它和应用程序最大的不同在于，它具有对整个计算机系统的控制权，它能够执行特权指令，它是一个可信任的软件，它不像应用程序，不可信任，有些恶意的程序会对我们系统造成破坏，但是我们信任操作系统，可以给我们提供一个安全的服务，所以说我们应用程序不能够直接去访问外设，因为直接访问外设，很容易造成计算机系统的崩溃，这是安全的角度，另一个角度，我们希望通过操作系统能够给我们上层应用提供更简单一致的接口，使得上层应用不需要关注底层细节，通过操作系统屏蔽底层device的复杂性和差异性。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE2c2b97b2f43e5b57e74eb923ab86aee1截图.png)

三者之间有什么特点和区别？

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE2881b02854d82c0d137ce5a2fb4f6a54截图.png)

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE183983b2d18adad69f28eb44917388ab截图.png)

首先从源头来看，中断 异常 系统调用三者产生源头是有不同的，中断是由外设产生的，外设有键盘鼠标等，  键盘敲击的字符的事件，鼠标会产生移动的事件，还有网卡可以产生网络包事件，还有声卡显卡都可以产生各种各样的事件让操作系统进行处理，这个称为中断事件。

异常，应用程序意想不到的行为，比如，程序在执行过程中做了除以0的操作，这个其实是让计算机不能正常工作的指令，为此操作系统需要能够去发现这种情况，及时进行处理，这是一种情况，另外可能有恶意的程序，由于某种原因，需要越过某种权限去访问另外一个程序的地址空间，这个地址空间其实应该是受保护的，这种情况应该被操作系统及时的截获，这也是一种异常，甚至还有一种情况，当我们应用程序在执行过程中，它需要的资源没有得到满足，这个时候呢操作系统悄悄的在后端把这个事情给处理好，然后让我们应用程序再去执行，没有得到满足这个异常事件呢促使我们操作系统去更好的为应用程序提供服务，所有的情况，其实都不是应用程序主动想去发出一个请求，而是让操作系统应对一些意外事件。

系统调用，和异常一样也是应用程序产生的，但是系统调用是应用程序主动要求的，很明确要求操作系统给我提供什么服务，有很明确的指令和相应的参数来说明我到底需要一个什么样的请求，比如说，打开文件关闭文件读写文件，发送网络包，等等 都是系统调用，这些都是用操作系统具体完成的。我们应用程序只需要按照我们定义好的系统调用的接口，把接口的参数设置好之后，具体的实现是由我们操作系统完成的，操作系统完成后，我们应用程序得到这个返回结果之后，可以继续去做该做的事情。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE96d85e29e573006d56ae92124f89721e截图.png)

中断一般称为异步事件，什么叫异步呢？当这个事件产生的时候，应用程序并不知道什么时候产生，

异常和系统调用呢，比较明确，异常是执行某一条特定的指令后一定会产生，比如说除0指令，一定会产生异常。

执行一条系统调用之后呢，也是在一个特定指令触发这个系统调用请求，让操作系统来完成，这个指令的位置是一个所谓同步的点。

还有一点就是系统调用有可能也是异步的，这个异步体现在另一个特点上来说，就是系统调用，当它发出请求之后，它的返回的这个时间是异步的，正常情况下，我们的返回也是同步的，当一个系统调用发出之后，比如我们要读一块数据，发出这个请求之后呢，我们操作系统就应该读数据的处理，最终把数据返回给我们系统调用，返回给发出这条指令的应用程序，但是发出系统调用的程序它在这个过程中其实是一直处于等待状态，这个实际返回是一个同步过程，但如果说我们应用程序发出请求之后马上去做其它事情了，那这个时候操作系统在完成了读数据的操作后呢，它会给应用程序发出异步一个消息说这个事情做完了，实际上返回过程是一个异步执行过程。

从中可以看出，对于系统调用而言，它发出的那个请求的点事同步的，但是它返回的点是有可能异步的也有可能是异步的，这个是和异常、中断不一样的地方。

中断是外设的命令进入排队，然后告诉CPU这边有活了，但CPU还在干自己的活；

异常是CPU执行命令时出错了直接干停了；

系统调用就是看CPU需不需要停了。

同步是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，知道收到返回信息才继续执行下去

异步应该是指不立即执行中断请求，同步是发生了异常应立即处理，系统调用可以立即处理也可以稍后处理。

异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其它进程的状态。当有消息返回时，系统会通知进程进行处理，这样可以提高执行效率。

 

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE4c1a3637b779272f430305cbb9d9ddbc截图.png)

对于中断而言，它打断了当前程序的正常执行，但是我们应用程序并没有感觉到中断产生，为什么呢？因为操作系统把这个过程悄悄的完成了， 并没有影响应用程序，所以在应用程序执行的过程中，其实你感觉不到时不时产生的中断，中断过程完全是由操作系统透明的完成的，对我们应用程序是透明的，这是中断的过程。

那么异常不一样，一旦产生异常，有可能导致严重的后果，把产生异常的程序给杀死，让它退出，这是严重的情况。也有就是让产生异常的程序重新执行产生异常的指令，有可能再次执行之后这条异常的指令可以正常执行。

对于系统调用而言，它的处理过程一般是等待服务完成后就继续执行了，它不会重复去执行系统调用的指令。
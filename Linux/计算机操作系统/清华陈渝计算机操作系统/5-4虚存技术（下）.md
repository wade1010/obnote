![](https://gitee.com/hxc8/images8/raw/master/img/202407191129919.jpg)

上图，字面意思也很好理解，需要访问这个页的时候，才把这个页调到内存中来。

页面置换：访问过程中，随着程序的执行，占用内存越来越多，有可能不够用，这时候就需要把某些换出去，某些需要的页换进来，这个换入换出就是置换页面，这个功能实现的好坏决定整体的效率。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191130794.jpg)

为了实现请求调页和页面置换，需要在页表项里面增加一些bit位来辅助，有4个位是比较重要的，如上图，驻留位、保护位、修改位和访问位

修改位，这一点很重要，如果被修改过，在内存中维持的数据是和之前放在硬盘上数据是不一致的，这个时候最新的数据放在内存中，在做这个换入换出的时候，我们需要把这个数据给导回到硬盘中去，使得硬盘中保存的数据和内存中是一致的。 如果这个修改位是0，也就是没有修改，它的数据和硬盘上的数据是一致的，这个时候就不需要写回，如果要把这个页去掉的话或者换掉的话，直接释放就OK了，因为内核和硬盘是一致的，下次需要再从硬盘调就行了。   通过对修改位的时候，可以有效的提高置换的效率。

访问位，也很重要，在后续讲到的置换算法中，要把一些页换出去，到底换哪些页，应该是换当前尽量是没有访问的页，这个位一定程度表明这个页是否经常被访问，如果这个页经常被访问，应该置成1的，既然没有置成1，意味着这个页很长时间没有被访问了，这个页也许不是我们将来很近的一个时间内，它会访问的到页，把这个页给换出去。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191130688.jpg)

上图 X代表驻留位为0，如果是个具体的数，驻留位就是1，

在这种情况下，比如想把虚拟的0地址赋给寄存器，做这么个操作，通过上图可以发现0地址在页表里面映射的页帧号是2，驻留位为1，每个页的大小为4K，4096X2=8192，实际访问的物理地址是8192，这里没有问题，能正常访问。

接下来操作是要把虚拟地址32780的内容读到寄存器里面去， 32780对应的是第8项（32K-36K）这个区间，里面的驻留位为0，所以没有对应的页帧号，也意味着访问这个页会产生缺页异常，这个机制就和我们进一步去使用，来把相应的页从外存调进来，通知我们操作系统该干事情，

 

![](https://gitee.com/hxc8/images8/raw/master/img/202407191130512.jpg)

上图是整个缺页过程做个介绍，缺页  异常的处理在整个虚拟页适配当中起到很重要的作用，它具体导引了如何来把这个页，什么时候需要以及如何把这个页从外存导到硬盘，已经从内存写到硬盘的过程。

上图是大致处理流程，左侧是文字描述，右侧是图形描述。

缺页中断处理过程：

CPU执行一条指令，load一个内存地址，那如果这个内存地址没有映射关系，页表中驻留位为0，这时候就产生缺页异常。一旦产生缺页异常，接下来，所有控制权交给操作系统，操作系统在缺页异常这个中断例程中就会完成相应的一系列工作，干什么呢？首先第一步，看一下内存中是否有空闲的物理页，假如有，就会分配一个空闲的物理页帧，转到第4步去，需要把这个页，需要访问的地址对应所在硬盘中的数据，以页为单位，从硬盘读到内存中去，读到内存什么地方呢？刚才你分配的物理页地址，把这个页内容读进去之后呢，第二步要干什么呢？修改页表，因为这个物理页存在了，需要把这个虚拟地址对应的页表项的页帧号写成现在这个物理页的页帧号，写好后，把驻留位置成1，表明这个页是存在的，再跳回到刚才产生异常n那条指令去重新执行这条指令，从而正常继续执行。这是一种情况，

第二种情况，如果现在空闲页没有了，空闲的物理空间没有了，需要有一种页面置换算法，假定我们根据某种算法选择了某个物理页替换出去或者清空，所谓清空，还需要注意一点，如果里面的修改位为1，我们需要把数据写回到硬盘中，如果修改位为0，直接可以释放，释放之后就可以再继续完成刚才的，根据访问地址从硬盘把相应数据读进来，然后设置页表项， 后面操作过程和前面一样。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191130051.jpg)

这里面提到大量的内存数据是放在外存中的， 需要再读进来，硬盘存储的特征，这里面有好几种存储形式来放置我们在内存中所对应的哪些数据或者代码。

第一个是数据，比如前面的例子讲到，访问一个数组，这个数组是一个大的数据，它肯定是一个数据文件放在了硬盘上，当需要访问某些地方的时候，如果内存中没有，就从数据文件中把数据读出来，是一种后备存储，

 第二个呢代码，就是说我们的操作系统让程序在执行过程中h会去执行每一条指令，这个指令其实也是一种数据，这种数据放在执行程序里面，放在硬盘中，也是一样，它把执行程序里面的代码当作数据读到内存中去，然后让CPU去执行者一条条指令，当我们去访问一条指令，不存在的时候呢，会进一步从执行程序中读到内存中来，进一步执行，这属于代码的后备存储。

第三个，属于动态链接库，软件在运行过程中可能需要很多库，这些库其实也是放到我们硬盘中的，需要的时候才把库的硬盘和数据读进来。

最后一种，不是以文件的形式存在，而是以分区的形式存在，这什么意思呢？实际上是说，程序在运行过程中，它有可能产生很多数据，这些数据没有对应到，具体的刚刚说到的文件（数据文件、执行文件、库文件），它是动态产生的数据，这些数据也有可能占了很大的空间，切需要被换出到硬盘上去，这个放到什么地方呢？操作系统会专门在硬盘上开辟一个区域，叫做swap，换入换出分区，在这个区域里面放置这些没有对应到文件的内存内容。

上述4类，形成了后备存储或者叫二级存储。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191130425.jpg)

上图公式，如果p足够下，就可以使得平均访问时间j接近于10ns，如果p非常大，会导致整个虚存管理效率会很差。

我们有信心保证p很小，因为程序具有局部性特点，意味着产生缺页次数会很少。
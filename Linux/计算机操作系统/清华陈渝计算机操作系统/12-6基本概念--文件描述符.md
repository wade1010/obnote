 文件描述符已经从直接用户变为编程人员的角度。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191118537.jpg)

open()打开文件为了做更简单的文件处理，会返回一个文件描述符，实际上是一个整型的数，这个数代表这个文件，

read和close，都需要使用文件描述符做参数，文件描述符代表文件给应用程序做各种各样访问和控制，那文件描述符是一个整数，怎么代表呢？

其实不仅仅是个数字，而是在操作系统内核里面，它对每一个进程打开的文件，他有一个表叫做 打开文件表，而文件描述符就是这个表的index，这个文件描述符指出了这个打开文件表的第几项代表这个文件，而这每一个项实际上是包含了很多文件的元数据信息，所以只需要知道它的索引就OK了。

当我们操作系统得到用户的请求，比如read write,会查这个打开文件表，然后根据index查到相应的文件信息，然后做进一步的读写操作。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191119805.jpg)

文件是共享资源，允许多个进程打开同一个文件。

文件磁盘位置：一般打开文件是要读和写文件，需要知道文件在磁盘上的位置，这样能够进一步去访问磁盘的扇区的内容，把这个内容读到内存里面来，完成对文件内容的读或者将来的写回也是一样。

 

![](https://gitee.com/hxc8/images8/raw/master/img/202407191119789.jpg)

在高层的操作系统里面，它其实不用关心你要存到什么地方，只是open read write，读写一块buffer，最后会由文件系统会把这一堆在内存的buffer对应到磁盘上去，把这关系建立好，来完成对磁盘的读写。

操作系统内部很重要一个信息就是在于它是怎么能够把一个磁盘块和一个文件的数据给对应起来，建立好映射关系。

对于一般扇区来说一般是512个byte或者4K，对于内存来说它的管理单位更多的是页，一个页可能是4K或者更大，那怎么在这两者之间建立相对应的关系？

在真正读写的时候，可能更多的是基于字节为单位进行读写，但是我们对磁盘的读写来说是以扇区为单位的读写，这两个有差异性，这个差异性能不能通过文件系统的有效管理把这个差异性给屏蔽掉。使得在用户角度或者高层系统角度不用care怎么完成这个转换。这是由文件系统来搞定的。

下面举个例子：

![](https://gitee.com/hxc8/images8/raw/master/img/202407191119632.jpg)

在文件系统中的所有操作都是在整个块空间上进行的

>举个例子，getc(),putc():即使每次只访问1字节的数据，也会缓存目标数据4096字节

上图，他会把包含2-12自己的扇区给读到我们的内存中来，它一次读就是读一个或者N个扇区，然后再从这个大的读到内存中的buffer里面把你需要的数传给用户，这是我们操作系统要去做得事。

文件系统中所有的操作其实都是在磁盘块空间来完成的。即使你只是读1个字节或者写1个字节，其实也会涉及到读磁盘块，一个磁盘块或者几个磁盘块来完成这些工作。

用户看到和系统看到不一样，特别是在底层系统里面。它需要区看到的是具体的磁盘块。而用户看到的是抽象的一维线性空间。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191119005.jpg)

基于内容访问：

![](https://gitee.com/hxc8/images8/raw/master/img/202407191119079.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191119697.jpg)

操作系统都是字节流

![](https://gitee.com/hxc8/images8/raw/master/img/202407191119293.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191119480.jpg)

确保多次写操作是写在不同地方或者互斥的方式进行写操作。就可以确保写的内容不会出现这种意想不到的情况。

打开文件 读写文件再到关闭文件，有一个打开 关闭的过程。就形成了所谓的会话。只有当一个文件做了关闭操作，我们才把它的数据会写回到我们的硬盘里面去，使得接下来再打开同一文件的进程可以把数据读出来。

锁也是为了支持共享，对于一个文件而言，我们建立在哪个粒度上的锁来完成对文件的保护，粒度可以是以一个文件，比如说打开一个文件后，我们酒吧这个文件的访问权限给锁住，别的进程就不能够打开了，

还开以这个文件中不同的位置不同的块来形成锁，这个锁粒度更小，只要它的块之间不出现重叠，那即使我们做并发写操作也没关系。这个锁粒度可以减小，那么我们操作系统呢这方面会提供不同粒度的锁
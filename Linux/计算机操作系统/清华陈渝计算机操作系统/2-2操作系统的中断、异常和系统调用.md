中断是外设的事件

异常是内部CPU的事件

中断和异常迫使CPU访问一些被中断和异常服务访问的功能

硬件

设置中断标记（CPU初始化）

- 将内部、外部事件设置中断标记

- 中断事件的ID    中断事件的ID指程序访问的中断向量地址。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCEa53c81c4679c369f5c720920940b7031截图.png)

中断和异常的处理过程：

他们都有一个硬件的处理过程和软件的处理过程。这两者结合在一起才能正确完成一个中断或者异常的操作系统的具体的一个服务。

首先产生一个中断或者异常之后呢，需要知道这个具体中断或者异常是由哪个特定的服务例程来服务，这一点需要去判断的。为此需要建立一个表。

它的key是中断号或者是异常号，因为每一个中断和异常把它编号之后，很容易区分出来到底产生的是硬盘的中断还是键盘的中断还是鼠标的中断，这很容易区分出来，不同的外设产生的中断，它都有一个特定的编号，有了这个编号之后呢，对于特定的编号，我们就有一个对应的地址，这个地址实际上就是针对这个特定中断的服务例程的地址。有了这个地址之后，假定操作系统收到了这个中断，收到中断之后可以直接根据这个表，查找这个表（中断表），可以查到它对应的那个中断服务例程那个起始地址，直接转跳到那里执行，这实际上是一个简单的描述。

如果需要系统正常的完成工作，还需要完成更多的事情，因为产生中断后，是打断了当前的正常执行，来处理一个更加紧急的外设的一个中断事件，那你打断一个程序的正常执行的话，我们需要在硬件和软件方面做出一定的保护，或者称之为保存与恢复机制。有了这个保存和恢复之后呢，我们才能让我们整个系统在完成完中断处理后，能够正常继续运行，这也是我们说中断处理过程中需要主要的实现细节。

这里面分两部分完成，

第一部分硬件：

硬件（外设是一个硬件），当它需要操作系统产生相应的支持之后呢，需要产生一个标记，会让我们CPU知道产生一个标记之后呢，就知道中断产生了。 CPU看到这个标记之后呢，他能根据这个标记得出到底是哪号中断，为什么会产生一个具体中断号，然后把这个中断号发给我们操作系统，从而操作系统根据这个中断号找到对应的处理例程，这是硬件完成的事情。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCEc7236ded083ac8aae47507e5720e79e9截图.png)

第二部分软件：

 软件是我们操作系统，那操作系统具体需要干什么事情呢？首先需要保存被打断的那个执行现场。

什么叫被打断执行现场？

程序正在执行过程中，突然产生个中断，首先需要把这个程序它当前的状态保存起来，比如执行到什么地方了，它执行的寄存器内容是什么，这些都要保存起来，便于我们后面去恢复的时候能正常让我们程序从被打断的点继续往下执行，这是要去保存的过程，这是由操作系统完成的，需要保存当前被打断程序的执行现场。这是一个。

第二个保存完之后，可以说，根据我们CPU给的中断号呢查到对应的中断处理例程的地址，然后跳到拿取执行。这个过程中，它会根据外设的产生中断的具体情况，来完成相应的操作。比如说，网卡外设，来了个数据包，那你这个中断服务例程需要去把这个数据包取出来，做进一步处理，这是我们说中断服务例程要做的事情，当中断服务例程处理完之后，应该让我们当前被打断的程序去继续执行，这就需要恢复刚才保存好的数据、保存好的寄存器，它的地址，把它们恢复回去，从而使我们这个程序在完全不知情的情况下继续它的执行过程。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCEebdfc3ca15f395da205b3924d1e44372截图.png)

但是异常处理不太一样，异常她也是一样，当我们应用程序执行某条特定指令后，这条特定指令触发一个异常事件（比如除0操作）他也会有一个异常编号，CPU会得到一个异常的ID号，对于这个ID号，操作系统首先也是一样它需要保存产生异常的执行现场，执行这条指令，产生异常指令的地址，以及当前寄存器的一些内容，保存好之后呢，操作系统根据异常编号去做相应得处理，如果处理结果是决定让应用程序退出执行，那操作系统会把程序杀死，这是一种情况。

另一种情况，也有可能操作系统认为这个程序产生异常是由于操作系统服务不到位，我们服务应该把产生异常的现象弥补好，让我们程序可以继续执行，这种情况下，操作系统要完成相应服务的一个弥补工作，弥补完之后，根据刚才异常产生的现场进行恢复，保存的那些值，那些寄存器，保存的地址恢复之后，让我们应用程序重新执行，需要这一点，这个和前面说的中断和系统调用不一样，是重新执行这条指令，那么这时候在重新执行过程中，由于我们操作系统已经把它这个产生异常的原因给修补好了，所以我们应用程序再次执行这条指令的时候，就不会再产生异常了，意味着我们程序可以继续的往下执行。这个过程对我们程序也是透明的。我们应用程序根本不知道在执行特定指令会产生异常，这一点和中断处理时类似的。

中断恢复现场后指令向下继续执行，

异常恢复现场后再重新执行发生异常的指令，再向下继续执行

#### 系统调用详细分析：

系统调用和前面所说的中断和异常不太一样，系统调用是应用程序需要操作系统提供服务，而这些服务不能由应用程序直接来执行，必须要由操作系统来执行，那么这个过程需要有一个接口，这个接口我们称之为系统调用接口。那么有这个接口之后，我们就可以让操作系统给应用程序提供各种各样的服务。

 

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE64bdfa13ba3a1a7ccb0e9500b10be143截图.png)

举个例子，简单c程序，有一条指令叫printf,打印在屏幕上，打印字符串是一条指令，这条指令，最终会触发一条系统调用，一个write系统调用，这个write系统调用会带一些参数，这个参数包含了你要让哪个设备来显示这个字符串以及字符串的内容，然后我们操作系统在获取这个参数之后，会去直接访问对应的设备，比如说屏幕，让我们的屏幕把字符串显示出来。这里面整个过程是操作系统来完成的。不是我们应用程序来完成的。应用程序只需要发送这个请求就行了，当操作系统完成这个请求之后呢，它就会返回一个成功或者失败，让我们应用程序能够知道，能够继续后续的执行操作，对于其它的系统调用大致过程一样，只是执行的具体内容不一样。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE311131c9ca5a16b312b7338154944fab截图.png)

上图是一个通用的系统调用的接口，有了这个接口之后呢，我们的应用程序，就开完成各种各样的功能了。来对这个计算机系统进行一个间接的控制和管理，

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE564471c084c7d591298563df4fd05784截图.png)

方便应用程序使用操作系统的系统调用接口，有很多定义好的API,

比如Win32的API，windows应用程序可以用这些API访问windows提供各种各样kernel的service

对于Unix而言，比如linux，它们会有一个标准的POSIX API，POSIX的意思是通用可移植系统调用的标准接口，这个标注让应用程序在不同的操作系统里面，只要符合这个接口的就可以执行。这样可以实现很好的跨平台

另外JAVA也提供很多API ，这些API不是系统调用，是JVM提供的支持，是一些库来提供的，最终还会提供类似于WIN32API或者POSIX API来实现相应操作。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCEf793f8a8d84949513af8410ee51492ed截图.png)

#### 操作系统怎么去完成系统调用调用的？

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCEea7108df038fdd14fdf959ddcd71b8e1截图.png)

上图可以看出，应用程序会直接或者间接通过一个library来访问系统调用的接口，然后一旦访问这个系统调用的接口之后，会触发一个用户态到内核态的转换。

用户态：是指我们应用程序在执行的过程中，CPU所处于的一个，执行的一个特权集状态。它特权集特别低，不能够直接访问某些特殊的机器指令，和直接访问IO。

内核态：操作系统运行过程中,CPU所处于的一个状态。在这个状态下呢，我们操作系统，可以执行CPU提供的任何一条指令，包括特权指令，包括访问IO的指令，使得安全性得到保证。

当程序处于用户态的时候，它无法执行这些特权指令和访问IO，无法完全的控制整个计算机系统。

内核态时是完全可以控制整个计算机系统的，

有了systemcall 这个interface之后呢，我们操作系统需要完成一个特殊的转换就是，当应用程序调用一个系统调用时候，会完成从用户态到内核态的转换，从而使得控制权从应用程序交到了操作系统。那么操作系统可以对这个应用程序发出的这些系统调用的参数，系统调用的ID号，做出一个标识，做了标识之后呢，可以使得它对系统调用做出一个识别，完成具体的服务。这是他的一个处理过程。

需要了解到的是，除了特权集的转换外，还需要有一些新的变化，主要是区分系统调用和传统的函数调用时有区别的，有两点：

当我们应用程序发出函数调用的时候，它其实是在一个栈空间完成函数之间的参数传递和结果返回，

而系统调用执行过程中，我们应用程序和内核是拥有各自的堆栈，也就意味着，当我们应用程序发出系统调用之后，当他切换到内核里面执行后，它需要去切换堆栈，同时还需要完成特权集的转换，从用户态到内核态转换，这个转换和堆栈的切换都需要一定的开销，也意味着，当执行系统调用的时候，它带来的开销比函数调用开销大很多，但是这个开销是有一定的回报的，回报就是使得操作系统安全可靠，这是操作系统为此付出的一个时间上的代价。

关于系统调用、中断、异常，它们在操作系统一个大致处理过程以及它和我们的应用程序以及device大致的一个交互过程，那这个过程，可以看到，跨越了操作系统的边界。  

到底是哪些代价？

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCEe7e7b75de47a5293ca5315b5b4edaa30截图.png)

让产生不同的异常、中断、系统调用，能够让操作系统能够正常的处理，

首先需要有对应的映射关系，就是说对应的具体的系统调用号、中断号，对应的具体的中断号，它应该由哪个中断例程或者哪个系统调用服务例程来处理，这有一个映射表，这个表需要在，能够让他正常工作之前就要建好，操作系统初始化环节就要建好。

第二，操作系统它由自己的堆栈，它不能和应用程序堆栈混为一谈，这样就使得有一个维护堆栈的开销，操作系统退出的时候把堆栈保存，进入的时候需要把堆栈恢复，同理一样，应用程序退出执行到内核来执行的时候，需要把应用程序的堆栈做一个保存，以及最后会做一个恢复的过程，这是有开销的。

同时呢操作系统不信任应用程序，它可能认为应用程序由恶意行为存在，所以说，它在收到应用程序发出来的系统调用之后，会对参数做一些检查，这个检查也需要一定开销，主要是安全上的开销。

还有一点，操作系统它有可能当他处理完数据之后，需要把数据从内核态导入到用户态，这个导的过程其实是拷贝的过程，内存拷贝会有新的开销，它不能像应用程序在执行过程中简单使用指针传递来实现，它必须要把n内存空间的数据从内核空间拷贝到用户空间，这个是拷贝开销。

以及随着我们应用程序的执行，有可能会引起内存状态的一个改变，这个是后续课程会讲到，所谓的页机制的一种转变。

cache TLB（Translation Lookaside Buffer 转换旁路缓冲区）这是计算机原理会提到的，关于CPU的TLB cache有可能会被刷新，他这个刷新过程会导致额外的开销。

这些开销是值得的也是必须的，使得操作系统是在一个安全可靠的环境中执行。
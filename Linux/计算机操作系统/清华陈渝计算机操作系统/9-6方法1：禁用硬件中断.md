![](https://gitee.com/hxc8/images8/raw/master/img/202407191122612.jpg)

中断除了产生硬件事件，让操作系统处理外，还有一个特征，前面讲到，当我们进程需要切换需要调度的时候，很重要一个中断就是时钟中断，有了时钟中断之后，可以使得当前这个进程即使它正在执行，也可以被打断，切换到操作系统来，由操作系统完成一个调度，切换到另外一个进程。这个中断，使得操作系统有了强制打断进程正常执行，完成进程切换的能力。这个能力本来是用在操作系统里面做调度，进程管理很重要的机制，但是这个机制也是导致为什么我们获得不确定结果的很重要原因，因为它随时可以切换，如果执行临界区代码不允许它切换，那其实就没有问题了，这段代码就可以得到确定的结果了，所以说在进入临界区之前把中断给屏蔽了，然后在退出临界区的时候再重新开启中断，这个问题确实就能解决了。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191123693.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191123367.jpg)

缺点：

这个中断最主要是用来响应外部事件，比如说外设产生的事件，及时的跟外设交互，比如网络包、时钟信号，磁盘块读写等等，如果屏蔽了中断，也意味着这些事件没法得到及时的响应，对效率是由很大影响的，

第二个临界区本身来说，它的执行事件长短是不确定的， 如果很长，对系统影响比较大，所以屏蔽中断的方法有一定的局限性。适合针对临界区很小的这种情况。

另外还要注意一点，如果说，这两个都要去执行临界区资源的进程是由两个CPU来并行的执行的话，这个中断机制，你只屏蔽一个CPU的中断机制是无法解决问题的，就是中断机制对于多CPU的情况下，有一定的限制，因为当一个CPU执行屏蔽中断指令的时候，只是把自身的响应中断的能力暂时给屏蔽了，并不是说把其它CPU的中断也给屏蔽了，也意味着其它CPU是可以继续去执行，继续去产生中断，导致屏蔽中断这种方式在多CPU的情况下是无法解决这个互斥问题的。
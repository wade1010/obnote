![](https://gitee.com/hxc8/images8/raw/master/img/202407191122260.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191122381.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191122462.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191122711.jpg)

注意 while(flag[j]==1); 是伪代码，后面flag[i]=1;不是在循环内的，而是单独一条语句。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191122455.jpg)

 

![](https://gitee.com/hxc8/images8/raw/master/img/202407191122054.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191122512.jpg)

上面是能解决问题的皮特森算法

下面是另外一个正确实现的算法

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE6ea67c511ffcab30116aa8c858460617截图.png)

 

下图是针对N个进程的互斥保护

方法1

![](https://gitee.com/hxc8/images8/raw/master/img/202407191122004.jpg)

方法2

![](https://gitee.com/hxc8/images8/raw/master/img/202407191122932.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191122923.jpg)
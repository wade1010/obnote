父进程创建子进程之后，还需要等待子进程的结束，为什么要等待子进程结束？

子进程结束直接调用一个exit退出不就行了么？让父进程等子进程干什么呢？为什么需要wait这个系统调用？

当一个进程执行exit系统调用，退出了，执行完退出后，是否这个进程所需要的资源都会被会收到操作系统中来？

确实exit退出之后，操作系统会把当前这个进程，因为当前这个进程自身执行系统调用，在操作系统内部会根据当前进程的情况会把进程的用户空间，占用的其它资源，比如打开的文件等等，都给他关闭和释放掉，这确实可以做完，但是有一个资源，它很难回收，就是操作系统内部代表当前进程的存在的那个PCB，PCB是代表进程存在的唯一标识。现在我们操作系统说我们在执行退出操作，但是你执行的过程，还代表自己活着，n你把这些资源全都释放掉后呢，你是没法在回到用户空间去运行了，但是操作系统还在内核里面帮你在做这个回收操作，在这个时刻，当你把所有用户态资源q全释放之后呢，虽然已经无法在用户空间执行了，但是你还在内核空间里面h还有它相应的一些资源，比如说PCB，他本身回收就比较困难。

自身难以完成的事情，可以让父进程帮你完成，当子进程接下来会做exit时，执行到最后，它会返回，一旦返回，它会通过操作系统通知我们的父进程，如果这个时候父进程，在执行wait操作的话，这两个就对上了，wait，我们知道子进程执行了exit这个系统调用，我还收到了它执行完毕的信号，收到信号后，父进程就可以帮助子进程完成最后一步，就是把它在内存中的资源释放掉，最主要的就是PCB. 

这个就是靠父进程的wait系统调用来完成的。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191125958.jpg)

父进程的wait是配合子进程exit完成所有资源的一个回收。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191125797.jpg)

当子进程执行完exit之后，且父进程还没有执行完wait，就是没有把这个子进程的进程控制块等n内核的资源给回收的时候，这还有段时间，在这个时间里面，这个子进程并没有死亡，且也不属于之前所说的就绪态，运行态，阻塞态等。因为它已经没法再回到用户态去执行了，它这时候处于僵尸态，表明exit执行完毕到wait还没执行完毕之间的时间之内，子进程所处的状态。它其实没法正常工作，只是等着被回收。

那还有种情况，父进程先于子进程退出，意味着子进程不可能再有个进程来帮助它回收资源了，这该怎么办？

是不是说子进程对于的PCB没法回收了呢？

肯定不能这样，如果这样，我们操作系统中处于僵尸态的进程会越来越多，一般操作系统这么来设计，思路：

我们进程都有一个父子关系，最早那个经常我们称之为init进程，它呢，会定期的扫描进程控制块链表，看是否有这个进程处于僵尸状态，它会代表进程的父进程来完成回收操作，代理完成wait这个系统调用的操作。通过这种方式使得操作系统中不会有太多僵尸进程

![](https://gitee.com/hxc8/images8/raw/master/img/202407191125753.jpg)

exec和状态什么关系呢？

执行exec的时候，他在整个执行过程中，进程可能处于不同的状态，

首先执行exec，进程处于running把。

exec执行过程中完成两个事情，1 加载执行程序 2 运行程序，

在加载的时候，假定程序存在磁盘上，它会从磁盘读到内存中，这个过程花时间比较长，意味着可能会从running->blocked。
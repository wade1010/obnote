上一章节，缓存到TLB，从而不需要多次访问内存页表，这是速度上得到解决了，另一问题空间上，页表空间本身很大，怎么让页表所占空间尽量小。

可以通过多级页表来实现。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE738d24f0071d0fee967cbfbbc9a91073截图.png)

以2级页表为例，

上图把刚才单一的page table分层两块，变成两个table,既然变成两个table，其实对应的逻辑地址，也有区分，它把刚才的page num、page offset又进行了一个细化，offset没变，page num分成两部分，一个p1的page num 一个p2的 page  num.对应1级页表的页号，和2级页表的页号，使得对一个大的地址的寻址，变成对N个小的page table来进行寻址，而不是对一个很大的page table寻址。

寻址过程：

首先把大的page num 分成两块，p1 p2，寻址的时候首先要找这个1级页表，1级页表的其实地址是知道的， 把p1 num作为index，去查找对应的1级页表的页表项，就是存了一个值，但是跟之前的不一样，之前的是帧号，这里存的是二级页表的其实地址，知道二级页表起始地址之后，看上图右下方，它会根据二级页表的p2，把p2 num作为二级页表的index，再加上1几页表中查到的耳机页表起始地址，就可以在2级页表中找到p2的页表项，这个页表项存的是frame num。它把这个过程分成了两块，frame num+offset就可以找到物理地址了。

上述处理过程相对来说又多了一次寻址/一次查找/一次处理，而且这个页表都放到内存中的，是不是开销很大，没错，开销是很大，但是可以通过这种方式使得，某一些不存在映射关系的页表项就没必要占用内存了。为什么这么说？

比如说p1指向的1级页表项不存在的话，所谓的不存在就是驻留位为0，对应的p2的二级页表整个都没必要存在，没必要在内存中放着了。这就省空间。

如果对应前面讲的单一的页表的话，j即使映射关系不存在，对应的空间还需要保留，而在这种分级的页表机制下，这种对应的空间，没必要保留。这就省空间了。

把二级页表推广下就是多级页表

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE03e0f0526077cd20398c624aaaffa8da截图.png)

 

多级页表就是可以进一步细分，  像一个从左到右的树，树状结构就可以表示一个更大的地址空间，甚至说刚刚说的64位系统可以用5级页表来表示。

级数越多，意味着每次访问页表的开销越来越大，但是省空间了，就是以时间换空间，时间的开销可以通过前面讲的TLB来缓解

注意一点，能够根据这个地址切分很容易定位出来具体的对应的页表项在什么位置，这其实是需要一个计算过程去实现。
![](https://gitee.com/hxc8/images8/raw/master/img/202407191125624.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191125723.jpg)

在某个时刻决定选择那个就绪进程去占用CPU执行。

目标：使得系统效率更高。  

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE506846aae134f99c1443595e87fbfc73截图.png)

从一个状态到另一个状态变化的时候触发一次调度。因为这个都是否考虑让新的进程执行，或者让当前进程从CPU上撤下来，换一个进程去执行，这实际上就是调度时机，或者称为调度点。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191125596.jpg)

用户态抢占和非抢占，

非抢占式：进程启动后，别的进程不能打断，导致别的进程必须等待这个进程执行完毕才去执行。效率不高。

抢占式：用户进程在它的执行过程中，它感知不到，操作系统会决定，在某个时刻打断当前用户进程的执行，让操作系统去选择另外一个进程执行（操作系统认为更值得去执行的进程）称之为抢占式调用。现在操作系统常用调度策略

内核里面也存在是否可以抢占，

内核态非抢占：当一个用户进程执行系统调用，如果这个系统调用在内核中不会导致这个进程处于等待状态，它还是执行状态，这个时候，当这个系统调用返回的时候，一定会返回到发起这个系统调用的进程中去继续执行，意味着内核中不会出现抢占现象，不会在内核中切换，切换到另一个线程去执行，只要你这个进程在内核中执行，这个流程中它自身不会出现从运行态到阻塞态的变化，就确保回去的时候一定是，发起请求的进程继续执行。

内核态抢占：如果内核中也允许去做抢占，就是说有可能正在执行的系统调用，在内核里面执行的系统调用，某一个进程发起的，j结果由于特殊事件产生，需要把当前内核完成一次切换，切到另一个优先级更高的进程去执行，一旦之前那个系统调用返回的时候，在内核那一点，是从内核态返回用户态的时候，可能变成另一个进程去，这种情况称之为抢占式的内核。
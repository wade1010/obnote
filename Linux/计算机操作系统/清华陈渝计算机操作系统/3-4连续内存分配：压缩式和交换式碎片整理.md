减少碎片，前面说到了，无论采用哪种算法，都有可能产生内存碎片。

有什么事后能弥补下，让这个碎片尽量下。碎片少，意味着它的空闲空间尽量完整、尽量连续，大小会比较大，便于后续分配。

方法1：压缩式碎片整理

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE9bc449c60413bb8005d0a4711012a187截图.png)

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE84f2dcea96e9244a5cf48b753fcc89aa截图.png)

造成空隙的原因：之前分配给别的程序，程序退出，这一块就空出来了。

首先需要考虑两个问题，

1：什么时候做重新拷贝或者叫重定位，把程序从一个地方挪到另外一个地方，什么时候做是合适的？

2：考虑它的开销大不大。

首先什么时候从一个地方挪到另外一个地方，挪的时机，能够在程序执行的时候去做这个操作？运行的时候去挪的话，程序访问的地址可能就不对了。

既然不能在程序运行的时候去做这个事情，那能不能在程序停止的时候，它正在等待某个事情，程序放在内存中，他没有在CPU占用执行，这个时候让程序从一个地方挪到另外一个地方，这是可以的，（有人说这个类似拥有垃圾回收机制的高级语言里面的STW，stop the world）。这是可以的，但是需要考虑开销大不大，也许很快，但是频繁的做这个操作，内存拷贝的开销还是很大的， 甚至影响整个系统的正常执行。这种方法纯靠软件来完成的方法实际上是由很大的开销在里面的。

方式2：交换式碎片整理

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE283d31dbff7843d066feaee775ba6a55截图.png)

换入换出，把硬盘充分利用起来了。

其中的问题，

1：选择哪一个程序换出去？

2：到底在什么时候坐着换入换出操作？

3：另外一方面这个换入换出是以当个程序为粒度的，如果这个程序比较大，那么换入换出的开销就很大。

上述问题有什么办法去进一步完善？后续过程会讲虚存管理，会提到怎么去优化这个方法使得，更有效的去完成换入换出操作，目前换入换出是一个连续的大的内存块。希望将能将一个大块变成一个小块，做到更灵活的换入换出机制，需要后续的知识的补充。   

总结：

1：

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE590b6682e7e3e38709813e740cfe6705截图.png)

2：

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE7fe36e0a940bca0a27438deb19301d5f截图.png)

 地址包含两部分，一部分是逻辑地址，一部分是物理地址，通过编译器就把基于符号的地址空间变成基于逻辑地址的地址空间，这两者是通过编译器来完成的。

通过操作系统可以进一步完成逻辑地址到物理地址的映射，操作系统建立好对应关系，从而使得应用程序在内存中正常执行。

同时保证不同应用程序在执行过程中不会相互破坏，因为操作系统有安全检查。

2：

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE4d6038791b553c254c5a392b84efa80c截图.png)
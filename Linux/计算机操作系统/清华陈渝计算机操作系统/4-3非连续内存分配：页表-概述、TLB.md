![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCEce2451f7cfb44ca140be4058b5bcc70f截图.png)

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE09f3bb2fea38904c115e3742260cd099截图.png)

页表其实就是一个大数组，索引指的是page num，索引所对页表项的内容，是帧号 frame num

CPU会查找这个页表在什么地方，其实地址在哪，然后通过pagenum算出index,寻址到对应的页表项，把相应的frame num给取出来，有了帧号和偏移就可以按公式计算出对应的物理地址，

如上图，除了帧号外，还有相应的bit，这些bit有相应的用途，比如说，表示这个页表项是否是合法的页表项，对应的物理页在内存中是否存在。前面讲到，我们逻辑地址空间很大，有一部分逻辑地址空间是可能没有对应到物理地址空间的，这时候bit属性应该就表示不存在了，可能是1表示存在，0表示不存在。

当然还有其它的情况，代表页读和写的情况，是写过，读过，还是没有读，没有写，这一系列属性在这里面都开表示。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE8d756814a18c3c69fa2a4a6482c281cf截图.png)

上图是个例子，说先看下内存空间的大小，逻辑地址空间一共有16个bit，意味着有64K的地址空间,但是我们物理空间只有32KB。这就是前面所说的物理空间和逻辑空间是不一致的，但是他们页内偏移是一样的，页的大小和页帧大小都是一样的，都是1KB。

上图左边，逻辑地址(4,0)和(3,1023)，看看处理过程是怎样的，

首先CPU他要找这个逻辑地址，先看(4,0),查一下这个页表，第4项有一个标志位和相应的帧号， 标志位红色的0代表当前物理页帧是否驻留/是否存在，如是0代表不存在，如果是1代表存在，上图标识的是0，意味着，对应的物理页也就是页帧在内存中其实是不存在的，没有这个映射关系，如果说CPU访问了这个地址，他应该产生一个异常，就是内存访问异常。

接下来看第二个（3,1023），页表里面第四项，驻留位是1，代表的物理页帧确实存在，对应的页帧号是多少呢?由二进制表示，这里是00100，也就意味着它的页帧号是4，页帧内的偏移从逻辑地址可以得出是1023，这样就形成了一个物理页帧的地址，页帧号4，页帧内偏移1023，运算出来后指向上图左边的物理地址（4，1023）

主要存在的问题：

主要是空间的代价问题，另外一个是时间的开销问题，

举个例子，现在的计算机系统很多都是64位的，意味者它的寻址空间是2^64次方，如果一个页的size是1024个字节，请问这么大的寻址空间，需要建立多大的页表才能将这个映射关系表示完？

2^64/2^10=2^54   这是一个非常大的page table,一般计算机没有这么大的空间，完全没法存下这个页表，也就没法去完成这个对应关系。这是第一个问题，页表可能由于逻辑地址空间h很大，导致我们对应的页表也很大，这是一个。

第二个问题，计算机系统里面可以跑多个应用程序，为了有效地址空间隔离，需要每个运行的程序都有自己的页表。如果N个程序，对应N个页表，意味者页表所占的空间需要N份，这其实也很耗空间。

第一个问题页表可能导致占的空间很大，第二个访问效率问题，既然页表空间很大了，整个页表的组织结构，不能够放到CPU里面，因为CPU空间很小，CPU有cache，但是最多也就几M，这个页表按刚刚的设计是相当大的，CPU放不下，CPU放不下之后就只能放在内存里面，但是如果放在内存里面，每次寻址，寻找访问一个内存，我们要访问一个页表，而这个页表本身也在内存里面，意味着去做一次内存寻址，要访问两次内存，这个开销也是很大的。

所以说上述两个问题，需要减少时间和空间上带来的消耗，对计算机而言，解决时间或者空间问题，一般有两中办法，1缓存，把常用的数据缓存到离我们CPU很近的地方，就像前面内存管理系统说的有cache一样，2 通过间接的方式，可以把很大的空间拆成比较小的空间，多级页表机制k可以有效的缓解页表空间占用过大，

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE0122d76b20e5681b825a97710f178565截图.png)

下面讲解通过两种方法解决页表时间和空间问题。

首先讲时间问题，用到TLB，就是在CPU里面有个MMU，MMU里面有个TLB,这是一个缓冲cache,缓冲的就是页表里面的内容，

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE350001930e637475d3ab9fa2948b57cd截图.png)

上图，可以看到，TLB是一个特殊的区域，位于CPU内部，他里面包含了两个项，一个是p值，一个是f值，p值是个key，f值是个value,这一个k-v就形成了TLB的表项，而这TLB的表项本身是由相关存储器来实现的，相关存储器的快速查询存储器， 它的速度很快，可以进行并发的查找，但他的实现代价很大，容量有限，可以把当前经常映射的页表项，经常用到或者经常访问的页表项，把它放到TLB里面去，这样就可以提升访问速度，这样命中的话就不需要查页表了。当CPU得到一个逻辑地址的时候，首先根据这个p查TLB，如果TLB里面存在这个p的key，很容易得到这个f，有了f加上offset就可以得到物理地址，就可以去找内存中对应的内容了，避免了一次对页表的访问。

TLB容量有限，总会有访问不到的情况，如果出现TLB访问不到的情况，就是所谓的TLBmiss，那CPU会去查页表，页表里面应该有对应的一项，如果说这一项里面存的驻留位是1的话，我们就会把这项里面的frame num 号取回来，缓存到TLB里面。可以看到最常用的放到TLB里面，不常用的就没有了。

那TLB出现的缺失情况会不会很大呢？不会很大，32系统里面，一个页一般是4K大小，要访问4K次，如果每个地址都要访问的话，访问4K次才有引起1次TLB的缺失，这个还是一个可以接受的访问。

尽量使TLB确实尽可能的少，比如我们写程序的时候，写的程序尽量有一定的局部性，就是有访问的局部性，把它平时访问集中在一个区域，这样可以有效的减少TLB的缺失，编程的时候需要注意的。通过这个方式，尽量避免对内存页表的访问，从而使得整个寻址开销得到极大的降低。

还需要注意一点，TLB miss 之后，从页表取出来再存到TLB里面这个过程是谁做呢？这个跟硬件有关，x86的CPU TBL miss之后，从页表中取d对应的项到TLB中去的过程完全由硬件完成，不需要操作系统参与，但是对于另一类cpu,可能是由操作系统来完成的，这个是由软件来实现的。
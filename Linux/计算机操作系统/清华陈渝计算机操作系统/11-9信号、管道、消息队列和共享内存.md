![](https://gitee.com/hxc8/images8/raw/master/img/202407191116213.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191116148.jpg)

signal可以理解为软件level的中断。打断当前正在执行的应用程序，效率很高。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191116543.jpg)

signal怎么实现的？

我们知道信号这个机制是操作系统来完成的？

首先应用程序开始的时候注册一个针对某类信号的handler，把这个作为系统调用发给操作系统，操作系统看到信息后就知道，当产生这类信号的时候，操作系统会调用应用程序编写的对应的处理函数来处理。

第二步，一旦产生了这类信号，操作系统怎么能够让当前正在运行的进程，把当前工作给停下来，跳到信号处理函数去执行？这个就需要操作系统来完成，首先当操作系统收这信号的时候或者它做处理信号，它运行在内核态，当他要返回，就是从内核态返回用户态去执行要去相应信号的进程的时候呢，他要提前做好准备，什么准备？返回去的那个点，它要改成，去调用到这个信号处理函数的入口。怎么来实现这一步呢？结合之前学习的系统调用，它需要把那个系统调用的用户空间的堆栈进行修改，使得本来应该返回到调用系统调用的后一条语句去执行呢， 变成到这个信号处理函数的入口，同时再把这个信号处理函数之后要执行的那个地址作为它的后面一个栈帧的一个返回地址，这样就没问题了，因为这样之后，一旦从操作系统内部内核返回到应用程序去执行的时候，它会根据你留的这个栈信息跳到那个信号函数处理入口去执行，那时候回到用户态，用户态在执行完毕后，那个函数执行完毕后呢，它会继续返回到调用它的那个函数，这里就构造成被打断的那个地方，使他可以从那个地方继续执行。

所以为了实现这种信号机制，我们需要去修改应用程序的那个堆栈，这点比较特殊，一般编写程序不会这么做，一般只有木马病毒这么做，来完成特定的功能。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191116719.jpg)

把一个程序的输出重定向为另外一个程序的输入。

ls 和more能协同起来是因为它们有一个共同的父进程shell,可以接收父进程的一些资源，管道其实是以文件的形式存在的。

![](https://gitee.com/hxc8/images8/raw/master/img/202407191116906.jpg)

共享内存

![](https://gitee.com/hxc8/images8/raw/master/img/202407191116002.jpg)

![](https://gitee.com/hxc8/images8/raw/master/img/202407191116759.jpg)

上图，怎么实现两个进程共享一块内存？

可以把同一块物理内存映射到不同的进程的相同或不同的地址空间里面去。
![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE7f88c761950b2a7bbf2b4c46a91971f3截图.png)

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE02bae2461d34822e67fe38854d44e090截图.png)

地址空间定义：

前面讲到有两种地址空间，

1物理地址空间，是和硬件直接对应的，比如说内存条所代表的主存，以及硬盘所代表的另一种空间，这两种空间就是物理内存，物理内存管理和控制是由硬件来完成的。

2逻辑地址空间，就是指一个运行的程序，它所看到的内存空间，相对而言它所看到的地址空间更加简单，它是一个一维的线性地址空间，有这个一维线性地址空间之后呢，应用程序就很容易去访问，很容易去做相关控制和数据访问操作。

但是我们要理解两者之间是如何建立对应关系的，因为所有程序访问的逻辑地址空间，最终都是落实在物理地址空间中。

如上图，有一个指令，指令的逻辑地址可能是位于剪头所指向的地方，最终是放置在主存中，也有可能是放置在硬盘中。到底是放在主存还是硬盘是由操作系统来协调的。可以明确的是这个映射关系是需要操作系统有效进行管理的。

逻辑空间怎么生成的：

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE09a00980bbc43c2e33a214f9f0f66b21截图.png)

上图简单的C程序，通过编译呢，变成了汇编程序，这两者之间就有点区别，那么它的地址在哪里？怎么体现?

在C程序里面，函数的位置，变量的名字就是一种地址，这就是一种逻辑地址，是人更容易理解的一种方式。

另外一种就是汇编程序，更加贴近机器语言，更加方便与机器去理解，但是依然是用符号代表变量和函数的名字，相比机器语言，也能够更好的被人阅读。

这种汇编语言通过汇编器，可以变成机器语言，就是.o程序，这个.o程序特点是，都是从0开始的，然后呢，它会把里面的变量符号名和函数符号名转换成相应的地址，这个地址是一个相对从0开始的一个连续地址空间，这是一种逻辑地址。

其实一个大的程序，是由很多个小程序组成的，那这个小程序组成的过程呢，有可能会使得不同的程序之间的地址相互之间进行访问，可能形成一个很复杂的依赖关系，这个过程怎么处理的呢？这实际上是通过linker，另外一个编译过程中用到的工具来完成把多个.o文件最终变成一个单一的执行程序，比如exe file.这个exe file已经是可以在内存中执行的一个目前还存放在硬盘中的程序。在这个程序，我们可以看到，它的这个地址已经做了全局的分布，不同的.o程序它所访问的地址，已经能够在单一的程序中有相应的定义，但这定义呢，还不在内存中位置，所以说最后执行程序，放在硬盘中的执行程序，还需要通过一个loader（也是个应用程序）这个loader会把放在硬盘中的执行程序放到内存中去运行，这一步需要去完成一个，放在内存中的逻辑地址完成相应的分配，使得应用程序在内存中可以正常的跑，可以看出来相对执行程序而言，这个地址有一定的偏移，这个偏移量可以为0，也可以为特定的值，有了这个值之后呢，所有的程序都会依照这个偏移量l来进行正确的访问和指令的操作，那这个过程可以看到，是逻辑地址生成过程，从最开始的符号的逻辑地址到最终可以在内存中运行的这个具体的逻辑地址，他们中间经过了很多转换过程，这时候的转换过程，基本上不需要我们操作系统做任何的帮助，通过应用程序、编译器、loader就可以完成这个过程的建立。这是逻辑地址的生成过程。

需要注意的是，即使我们把这个执行程序放到内存中去了，其实还是一个逻辑地址，并不是物理地址。那和物理地址有什么区别呢？

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCEd49a5da569bfbf147426ab9157a9a65d截图.png)

上图可以看到我们应用程序访问一个指令的时候，这个指令所处的逻辑地址，是如何对应到具体的物理内存空间去的，这么一个过程。

那么这个图和前面讲到的计算机体系结构的图是大体一致的，有一点不一样，就多了一个映射关系，我们前面说的这条指令，这条指令有自己的逻辑地址，CPU要执行这条指令，要把这个指令从内存中取出来，指令放在物理内存的什么地方，其实CPU一开始是不知道的，它只知道这条指令有一个逻辑地址，它回去查找这个逻辑地址所对应的物理地址在什么地方，对应关系其实是在硬件中有一个MMU（内存管理单元），CPU里面有一个MMU。MMU中有一块区域表示了这个映射关系，这个映射关系也会在内存中有相应的位置，比如上图蓝色区域所示，我们称之为这个映射关系完成了一个逻辑地址到物理地址y映射，我们查这个表就可以知道一个具体的逻辑地址对应的物理地址在什么地方,一旦知道这个物理地址在什么地方,我们就可以,让我们这个硬件从相应的物理内存中把地址给取过来.

整个流程可以简单描述为如下几个步骤：

1 当CPU执行某条指令的时候，它的ALU部件，它会需要这条指令的内容，它会发出这个请求，他发出请求带着参数里面就是一个逻辑地址，

2 CPU里面的MMU查找逻辑地址的映射表总是是否存在对应的物理地址，如果有可以找着，如果没有的话，就会进一步处理，去内存中找，MMU没有就会到内存中的map找，

3 如果找到了，CPU控制器会给主存发出一个请求，意思是我需要某个物理地址的内容，这个内容就是那条指令的内容。

4  主存会把内存的内容通过总线传给CPU，CPU拿到这个指令之后,就可以开始对这条指令开始执行了。

在这里面操作系统的作用：

很重要的作用在于，它在上述4步之前，需要把映射关系建立好，这个映射关系就是逻辑地址到物理地址的映射关系，这个关系可以是放到内存中，由CPU来进行缓存，从而加快访问过程，这就是物理地址生成过程。

可以看出来逻辑地址和物理地址关系映射是通过操作系统来完成的。至于怎么完成，后面会进一步讲解。

![](D:/download/youdaonote-pull-master/data/Technology/Linux/计算机操作系统/清华陈渝计算机操作系统/images/WEBRESOURCE87a038d6206d492b080feaa1ee467b30截图.png)

另外一方面，操作系统很重要的目标是，确保放在内存中的程序相互之间不能够干扰，为此需要去确保，每个程序去访问的地址空间是合法的，或者说是在约束限制范围之内的。这个限制和约束也是靠操作系统来完成的。

如上图，操作系统首先要确保每个程序可以有效访问的地址空间，这个地址空间包含两部分，第一部分是其实地址，第二部分是长度，就可以知道有一块区域是属于这个程序可以合理访问的。一旦超出这个区域就是不合法的。这个表也是操作系统建设维护的。

一旦CPU要去执行某条指令的时候,它会查这个map，这个map会指出来程序访问的某个逻辑地址是否满足区域限制，如果满足可以正常根据映射关系找到对应物理地址的位置，然后把数据和指令给取回来。一旦说不满足，CPU就会产生一个memory异常，就是内存访问异常，从而让操作系统做进一步的处理。这就是地址安全检测的过程。
当我们使用计算机或者手机时，是否疑惑过，串行的单核处理器（和串行思维的大脑一样），是如何同时处理多件事情的？这就要谈到计算机中的并发问题（不同于多核处理器的多个逻辑单元真的在同一时间并行，**“并发”只是看上去像是同时发生的（实则仍是串行）**）。

要实现并发，设计软件时，就要考虑并发架构。并发模型很多，但对于我们普通读者，无需掌握所有的并发模型，只需“二八法则”，了解最主要的五个并发模型，即可应对通常的80%情况。五大并发模型分别是**（1）线程与锁，（2）函数式编程，（3）Clojure模型，（4）actor模型和（5）通信顺序进程**。

## 一、线程与锁

### 1、背景

为什么基于“线程与锁”的并发模型是目前最常用的一种并发模型？因为近几十年来，初代程序员们一直在用“线程与锁”模型来实现并发乃至并行处理。为什么一直使用？因为**“线程与锁”模型与计算机底层硬件运行过程的很接近**，甚至可以看成其形式化后的模型。但随着规模的增大，现代软件已变得越发抽象和复杂，上层应用离底层硬件太远，以致我们看到的结果是——许多“优秀的代码很少直接使用底层服务，而是在使用高层的服务”。（这也是为何要在介绍完“线程与锁”这个“霸主”后，还要继续介绍其它四个模型的原因）。

### 2、线程、并发与锁

如果把我们运行的应用程序比作火车（即每个手机APP进程都是一辆火车），那么**线程就相当于是火车的车厢** 。车厢不能独立行进，它需要成为火车的一部分，才能运行。同理，线程只能在进程下行进。一个进程可以包含多个线程（类似一辆火车可以有多个车厢），同时线程消耗的资源比进程小的多（即多个车厢比多列火车消耗资源少的多）。

由于一个进程中的所有线程，共享这个进程的有限资源。因此可能出现多个线程竞争同一资源的情况。为了保持公平性，系统订立了如下规定——哪一线程先运行，就先给它资源。但资源“库房”的“门”得它自己关上，于是有了加锁、解锁等操作。有了锁，更多线程的到来，也能自己排队、等待，而不会因“哄抢”（同时操作同个资源）而导致混乱（谁也用不好）的局面。

## 二、函数式编程

在“线程与锁”基础上，程序员又另辟蹊径，建立函数式编程模型。函数式编程模型抛弃了“可变状态”这样的概念（如线程的运行态、就绪态、阻塞态等），把“目光”聚焦在了数据（准确说是数据流）上。在函数式模型中，具有引用透明性的函数，可以进行基于数据流（dataflow）式的编程。所编**代码，只有在其依赖的数据准备好之后，才会启动、运行**。

## 三、Clojure模型

这个一个可以靠工具快速将串行操作并行化的模型。比如用clojure.core.reducers包这样的工具，就直接为您实现了Clojure模型。

1、**特点**：实现了标识与线程状态的分离

因为Clojure模型用到了持久数据结构——一种使用了（类似git中branch的）共享结构的数据结构。如果一个线程引用了持久数据结构，那么**其他线程对数据结构的修改，对该线程就是不可见**的，从而实现了标识与线程状态的分离。

2、**无锁的原子变量**

原子变量是无锁的。正常情况下，基于原子变量实现，效率会比基于锁的实现高（**前者的平均效率约为后者3倍**）。究其原因，是因为基于锁的实现，会发生线程间的上下文切换，而原子变量不会。

3、“**多个值需一致更新**”的两个方法

程序员时常会遇到“多个值需一致更新”的问题，他们常想到的方法是：**使用多个引用**并**通过同一事务**来保证其访问一致性。除此以外，也可以将这些值整合到一个数据结构中，并用一个**“原子变量”**（通常更简单）来**管理这个数据结构**的访问一致性。以上两个方法并无绝对优劣，您可以通过压力测试等手段对这两种方法进行性能评估，择优选择用“录用”哪一种。

## 四、Actor

actor模型可应用于共享内存架构和分布式内存架构（即适合解决地理分布型的问题，容错性也不错）。

1、在Erlang/Elixir中的别名

actor对象在Erlang/Elixir中被称为进程，不过此进程非彼进程，它仅消耗很少的资源，创建代价也很低，**比操作系统级的线程更轻量级**。

2、优点：实体内串行

Actor模型比Clojure模型更抽象，它由独立的、并发执行的实体组成，实体之间是通过发送消息实现通信。这些**消息被放了信箱**中（而信箱又与进程被紧密耦合）。消息的传输和封装机制被设计精密，虽然多个actor在同时运行，但它们并不共享状态。而在单个actor中，任何时间，它都是串行执行的。

3、缺点：信箱溢出

使用actor模型会遇到如**信箱溢出**等问题。同时，由于它没有对并行提供直接支持、多个actor实体并不共享状态，因此它**无法在细粒度并行场景中运用**。

4、与通信顺序进程的不同

actor模型重点在于参与交流的**实体**，而通信顺序进程（CSP）模型重点在于交流的**通道**。

## 五、通信顺序进程

通信顺序进程的英文缩写是CSP（Communicating Sequential Process）和Actor模型有相似也有不同，相似的地方在于，通信顺序进程模型也是由独立的、并发执行的实体组成，实体时间也是通过发送消息进行通信。

但CSP模型与Actor模型也有差别，那就是CSP模型不关注发送消息的实体，而是关注发送消息时使用的channel(通道)。channel是这样一类对象，它不像与信箱耦合的进程，而可以**单独创建和读写，并在进程之间传递的对象**。具体而言，一个channel就是一个线程安全的队列。这个队列具有如下特性——任何任务只要持有channel的引用，就可以向一端添加消息，也可以从另一端删除消息。 默认情况下，channel是同步的(或称无缓存的)。在非默认情况，即有缓存情况，当channel的缓存区有足够的空间时，向其中**写入消息的操作会立刻完成，而不会阻塞**。

## 六、总结

本文介绍了五大并发模型分别是（1）线程与锁，（2）函数式编程，（3）Clojure模型，（4）actor模型和（5）通信顺序进程。它们从不同的角度、层次，实现了并发的逻辑和高效。

# 七种常见的并发编程模型简介

1. 线程与锁

线程与锁模型有很多众所周知的不足，但仍是其他模型的技术基础，也是很多并发[软件](https://yingsheng.elecfans.com/app)开发的首选。

2. 函数式编程

函数式编程日渐重要的原因之一，是其对并发编程和并行编程提供了良好的支持。函数式编程消除了可变状态，所以从根本上是线程安全的，而且易于并行执行。

3. Clojure之道——分离标识与状态

编程语言Clojure是一种指令式编程和函数式编程的混搭方案，在两种编程方式上取得了微妙的平衡来发挥两者的优势。

4. actor

actor模型是一种适用性很广的并发编程模型，适用于共享内存模型和分布式内存模型，也适合解决地理分布型问题，能提供强大的容错性。

5. 通信顺序进程（Communica[ti](http://www.elecfans.com/tags/%E5%BE%B7%E5%B7%9E%E4%BB%AA%E5%99%A8/)ng Sequential Processes，CSP）

表面上看，CSP模型与actor模型很相似，两者都基于消息传递。不过CSP模型侧重于传递信息的通道，而actor模型侧重于通道两端的实体，使用CSP模型的代码会带有明显不同的风格。

6. 数据级并行

每个笔记本电脑里都藏着一台超级[计算机](http://www.hqchip.com/app/873)——[GPU](http://www.elecfans.com/tags/gpu/)。GPU利用了数据级并行，不仅可以快速进行图像处理，也可以用于更广阔的领域。如果要进行有限元分析、流体力学计算或其他的大量数字计算，GPU的性能将是不二选择。

7. Lambda架构

[大数据](http://www.elecfans.com/rengongzhineng/605233_a.html)时代的到来离不开并行——现在我们只需要增加计算资源，就能具有处理TB级数据的能力。Lambda架构综合了MapReduce和流式处理的特点，是一种可以处理多种大数据问题的架构
前言

*前面我们提到过很多个无监督学习方法，但是一直没有系统地介绍这些学习方法内容，这次将会从机器学习的角度去剖析它们。*

## 一、无监督学习与监督学习的区别

1. **原理不同** **已知类别的样本打标签。** **类别未知(没有被标记)的训练样本不需要给数据打标签。**

1. **核心不同** **分类聚类**

1. **定性过程不同** **直接贴上标签**

1. **维度处理不同** 

1. **可解释性不同** 

## 二、K-means

### 1.K-means的优缺点

1. **优点:**

1. 原理简单，实现方便，算法复杂度低，收敛速度快；

1. 模型的可解释性较强；

1. 调节参数的数量较少，主要需要调参的参数仅仅是簇数K；

1. **缺点:**

1. 采用迭代方法，聚类结果往往收敛于局部最优而得不到全局最优解

1. 易受噪声、边缘点、孤立点影响；

1. K 值需要人为设定，不同 K 值得到的结果不一样

1. 不适合太离散的分类、样本类别不平衡的分类、非凸形状的分类

### 2.各种距离

想要了解K-means的计算原理，我们首先要理解一些基础概念跟距离模型。 **首先我们设两个点 $x=(x_1,x_2...x_n),y=(y_1,y_2...y_n)$** 1. 闵可夫斯基距离 �(�,�)=(∑�=1�|��−��|�)1� 其中$p\geq1$,事实上这个也是一个$L_p$范数 2. 欧氏距离 欧氏距离是最常用的距离之一，其实是闵可夫斯基距离的特殊情况之一，是一个二范数，可以表征最短距离。 �(�,�)=(∑�=1�|��−��|2)12 3. 曼哈顿距离 曼哈顿距离也是很常用的距离之一，也是闵可夫斯基距离的特殊情况之一，是一个一范数，可以表征垂直方向上(x和y方向)的距离之和 �(�,�)=∑�=1�|��−��|

![](https://gitee.com/hxc8/images0/raw/master/img/202407172044229.jpg)

在这里插入图片描述

**图中绿色边是欧氏距离，其他都是曼哈顿距离**

### 3.K-means算法

**簇：所有数据点的点集合，簇中的对象是相似的 质心：簇中所有点的中心（由簇中所有点的均值求得）** 1. 随机初始化k个点作为簇质心 2. 然后将样本集中的每个点分配到一个簇中；计算每个点与质心之间的距离（常用欧式距离和余弦距离），并将其分配给距离最近的质心所对应的簇中； 3. 更新簇的质心。每个簇的质心更新为该簇所有点的平均值； 4. 反复迭代2 - 3 步骤，直到达到某个终止条件；

聚类效果的评价指标一般为**SSE(平方误差和)**，SSE越小越说明质点越来越接近簇心，聚类效果越好。 ���=∑�=1�∑�∈�(�−��)2

![](https://gitee.com/hxc8/images0/raw/master/img/202407172044945.jpg)

在这里插入图片描述

## 三、HAC(层次汇合聚类)

### 1.HAC的优缺点

1. **优点**

1. 距离的定义比较容易，而且比较自由

1. 可以生成非球形的簇，发现层次间的关系。

1. 有时可以不用指定所需类别个数，可以通过阈值来进行类的划分

1. **缺点**

1. 在建树过程中要计算每个样本间的距离，计算复杂度较高；

1. 容易受异常点的影响

1. 容易形成链状的簇

### 2.HAC的算法过程

1. 把每个样本归为一类，计算每两个类之间的距离，也就是样本与样本之间的相似度；

1. 寻找各个类之间最近的两个类，把他们归为一类（这样类的总数就少了一个）；

1. 重新计算新生成的这个类与各个旧类之间的相似度；

1. 重复2和3直到所有样本点都归为一类，就结束了

![](https://gitee.com/hxc8/images0/raw/master/img/202407172044772.jpg)

在这里插入图片描述

这样下来，你会发现通过这个手段，HAC生成了一颗自底向上的树，并且终止条件可以是一个阈值，比较两个类的距离，如果大于某个阈值就可以停止进行聚类。 **最后只需要在每一层上切一刀，相邻地叶子结点就是一个聚类。**

## 四、PCA算法(主成分分析)

**上面介绍的K-means与HAC都是聚类的方法，他们致力于将类别划分在一起，如何划分在一起，接下来将会介绍一些降维的方法。**

### 1.为什么要使用PCA算法？

1. 聚类的缺点是以偏概全，强迫每个数据都要归顺于某一个簇，但是事实上一个数据可能归顺于多个簇，包含多个特征，如果这样做将会丢失掉这个数据得到其他特征，所以应该找一个向量去包含这些特征。

1. 许多变量之间存在相关性，如果对每个指标进行分析，将会是孤立的，无法利用到数据中心的很多信息，所以我们要在减少需要分析的指标同时，尽量减少原指标包含信息的损失

### 2.PCA算法的优缺点

1. **优点:**

1. 各主成分之间正交，可消除原始数据成分间的相互影响

1. 用PCA技术可以对数据进行降维，同时对新求出的“主元”向量的重要性进行排序，根据需要取前面最重要的部分，将后面的维数省去，可以达到降维从而简化模型或是对数据进行压缩的效果。同时最大程度的保持了原有数据的信息

1. PCA的计算过程中完全不需要人为的设定参数或是根据任何经验模型对计算进行干预，最后的结果只与数据相关

1. 计算方法简单，主要运算是特征值分解，易于实现。

1. **缺点:**

1. 主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。

1. 方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。

1. PCA是无监督的，不知道数据的标签，这样在降维映射之后可能会把两类数据混到一起。

1. PCA是线性的，把一个三维空间中的S形分布的数据做PCA之后的效果，就是把S形拍扁，而非展开。

![](https://gitee.com/hxc8/images0/raw/master/img/202407172044654.jpg)

在这里插入图片描述

### 3.奇异阵分解(SVD)

### 1.奇异阵分解的作用以及应用

奇异阵分解的核心目标就是在低维空间中寻找最接近原矩阵A的低维矩阵M ,实现数据降维。 因为在数学上来说，一定能找到一个更低规模的矩阵去迫近原来高维度的矩阵，这样就实现了数据的压缩，提高后续处理的速度。 而奇异值分解的几何含义为：对于任何的一个矩阵，我们要找到一组两两正交单位向量序列，使得矩阵作用在此向量序列上后得到新的向量序列保持两两正交。 **奇异阵分解的主要应用:**

- 图像压缩

- 图像恢复

- 获取特征脸

- 谱聚类

- 从视频中删除背景

### 2.奇异阵分解原理

给定一个大小为M*N的矩阵A,我们可以将其分解成: **��∗�=��∗�Λ�∗���∗�** 我们可以看到 *U* 跟 *V*两个矩阵都是方阵，而中间的特征矩阵则是一个非方阵，接下来我们将对我们的A矩阵进行****对角化分解*** *���=�Λ1��* *���=�Λ2��** 由于对角化分解后的结果是一个方阵，所以这时我们的$\Lambda_1,\Lambda_2$则分别是一个$m*m$和$n*n$的方阵，而P的大小也是$m*m$,Q的大小为$n*n$。 对角化分解后的两个矩阵$AA^T,A^TA$之间存在很大的关系，我们会发现虽然它们的特征矩阵不同，但是它们在对角线上的特征值是完全相等的，接下来我们只要取特征矩阵较小的那个那个特征矩阵作为我们的$\Lambda$就可以进行迫近了，因为这个特征矩阵已经包含了整个奇异阵分解的大部分有用信息，最后得出的分解结果为:(假设特征矩阵的秩为k) ��∗�=��∗�Λ�∗���∗� **注意:这里的特征值是求平方根后的结果，必须要保证最后的结果是正的** 我们同时展开奇异阵分解，会得到如下式子: �=�1�1�1+�2�2�2+...������ 我们要做的就是将它们截断，截留前k个奇异值，得到新的迫近矩阵 �=�1�1�1+�2�2�2+...������

![](https://gitee.com/hxc8/images0/raw/master/img/202407172044512.jpg)

在这里插入图片描述

### 4.一维PCA的简单推导过程

**PCA的目标是找到一组新的正交基 （从n维下降到k维），使得数据点在该正交基构成的平面上投影后，数据间的距离最大，即数据间的方差最大，这样数据就会越分散，越能区分开它们。如果数据在每个正交基上投影后的方差最大，那么同样满足在正交基所构成的平面上投影距离最大。** 1. 设正交基$u_j$,数据点$x_i$在它上投影距离为$x_i^Tu_j$，则所有数据在这个正交基中投影所得到的方差为:��=1�∑�=1�(�����−����������)2 其中m是样本数量，数据运算之前先对数据x进行0均值化，也叫去中心化，令$x_{center}=0$ 接下来我们将式子展开，得到��=1�∑�=1�(�����)2=���(1�∑�=1������)�� 这个形式似曾相识，十分地与我们上面奇异阵分解的形式不约而同的相等，当我们将中间那串东西看作奇异阵分解中的特征矩阵即可化简成下面这种形式: ��=������ 其中$S=\frac{1}{m}\sum_{i=1}^mx_i^Tx_i$

1. 然后我们加入限制条件，也就是加上拉普拉斯算子进行限制:��:�����=1 �(��)=������+�(1−�����)  ���=���  �����=�������=��

1. 然后统计所以基底$u={u_1,u_2..u_j}$下的最大方差，可以得到: ����=∑�=1���**这里的j是按照特征值大小来进行排序的吗，所以投影正交基为S的特征向量中的前k个最大特征值对应的特征向量。**

1. 根据奇异阵分解，我们知道新的正交基$u\in svd(S)$,S即为X的协方差矩阵(同时是一个对角矩阵，因为$x_{center}=0$)。

1. 按照特征值从大到小排序，要降低为k维，那么取前k个特征值对应的特征向量，就是新的k个坐标轴

1. 最后将X映射到新的基底当中，完成我们的降维操作

![](https://gitee.com/hxc8/images0/raw/master/img/202407172044232.jpg)

在这里插入图片描述

### 5.更高维度的PCA投影

如果想要投影到更高维度，那么我们必须要设定多个维度的变换

![](https://gitee.com/hxc8/images0/raw/master/img/202407172044871.jpg)

在这里插入图片描述

这样随之而来的问题是会出现多个限制条件和多个方差函数，并且会出第一大特征和第二大特征，就会有多个特征向量值

![](https://gitee.com/hxc8/images0/raw/master/img/202407172044640.jpg)

在这里插入图片描述

## 五、manifold learning(流行学习)

### 1.为什么要使用流行学习？

1. 前面我们说过，PCA的降维是一种线性的降维方法，他把多维空间进行了压平，而不是展开，这样在计算欧氏距离就会产生问题，而流行模型在局部具有欧式空间的性质，可以利用这个性质进行降维映射，并且可以实现可视化。

1. 我们所能观察到的数据其实是由一个低维流形映射到高维空间上的（一个立方体可以展开为平面）。由于数据内部特征的限制，一些高维中的数据会产生维度上的冗余，实际上只需要比较低的维度就能唯一的表示。

![](https://gitee.com/hxc8/images0/raw/master/img/202407172044388.jpg)

在这里插入图片描述

### 2.多维标度分析(MDS)

### 1.为什么要使用MDS算法？

PCA的思想，它是找到一个最佳的投影方向使得数据在该方向投影之后保留足够多的信息。但这样只考虑了数据整体的分布情况（即方差），而没有考虑点与点之间的距离关系。但是我们希望降维前后能够保持距离关系不变，从而能够很好地进行可视化，而MDS算法能将距离固定为欧氏距离，保持彼此之间的相对距离变化最小，使其尽可能与原先的相似性大致匹配。

### 2.MDS算法步骤

1. 现在考虑将原始数据矩阵$X \in R^{d*m}$降维成$Z \in R^{d'* ����∑�,�(||��−��||−���)2 

1. 我们对这个最小值展开，我们将得到: ���2=||��−��||2=||��||2+||��||2−2||��||�||��||=���+���−2���

1. 然后进行求和得到: 中心化约束∑�=1����2=∑�=1����+∑�=1����−∑�=1�2���=��(�)+����+0(中心化约束)

1. 再对j求和得到结果是$2mtr(B)$

1. 根据上面的几个式子我们可以分别推导出$b_{ii},b_{jj},b_{ij}$的值，它们分别是

![](https://gitee.com/hxc8/images0/raw/master/img/202407172044090.jpg)

在这里插入图片描述

1. 接下来我们可以对B进行奇异阵分解了,实现降维。 �=���=�Λ��=(Λ12��)�(Λ12��)

1. 截断后得到MDS的解�=Λ�′12��′�

### 3.ISOMAP算法

**ISOMAP是一种特殊的MDS算法，只是在距离阵的计算方法中不一样，其他都是一样的**

![](https://gitee.com/hxc8/images0/raw/master/img/202407172045754.jpg)

在这里插入图片描述

1. 根据给定的欧氏距离阵，利用前面提到的最短路径算法得到调整的距离阵； 2. 将调整的距离阵代入MDS算法框架中。

**Isomap算法是全局的，它要找到所有样本全局的最优解，当数据量很大时或者样本维度很高时，计算量非常大。**

### 4.LLE算法(局部线性嵌入)

**LLE算法主要就是为了解决ISOMAP算法全局最优的问题，实现局部最优**

- **LLE算法的简单步骤:** 

![](https://gitee.com/hxc8/images0/raw/master/img/202407172045433.jpg)

在这里插入图片描述

step 3: 映射到低维空间,利用上面计算出来的最优解$w_{ij}$对低维空间进行映射

![](https://gitee.com/hxc8/images0/raw/master/img/202407172045190.jpg)

在这里插入图片描述

- **LLE算法的优点:** 

- **LLE算法的缺点:** 

### 3.t-SNE

### 1.t-SNE的优缺点

1. **优点:**

1. 如果用 PCA 降维进行可视化，会出现所谓的“拥挤现象”,而t-SNE就可以解决拥挤现象

![](https://gitee.com/hxc8/images0/raw/master/img/202407172045996.jpg)

在这里插入图片描述

1. t-SNE 更加注重保留原始数据的局部特征

1. **缺点:**

1. 只能可视化，不用于数据转换，这是因为中间并没有出现任何的结构型网络，只是简单地对原数据集进行迫近，当有新的数据输入进来时，将会重新进行训练。

1. 过于高维一般不直接使用，因为维数过高时，将会使变换矩阵十分地庞大，计算量过大。

### 2.t-SNE的过程

**与前面MDS的思想一致，在变换前后两个点之间的相对距离应该保持一致，也就是原先距离近的数据，降维之后距离应该也很近；原先距离远的数据，降维之后距离应该也很远。** 但是t-SNE的思想是将距离的远近看作概率分布，即变换前后都生成一个**概率分布**，通过**KL散度**来衡量它们的接近情况

1. 对于高维度中每一个数据点i，其概率分布为: �(�|�)=�(��,��)∑�≠��(��,��) 

1. 对于低维度中每一个数据点i，其概率分布为: �(�|�)=�′(��,��)∑�≠��′(��,��) 

1. 接下来引入KL散度来进行衡量两个分布的相似性: �(�1,�2...��)=∑�=1�∑�≠��(�|�)log⁡�(�|�)�(�|�)

1. 用梯度下降算法求得令损失函数最小的那一组z，必要时可以加入动量来加速我们的收敛。

### 3.t-SNE的相似函数

在SNE中我们采用的是指数分布，因为指数分布的收敛快，只要距离一拉开，那么相似度迅速减小，从而在低维空间中将那些稍有间隔的点拉得很开。 �(��,��)=���(−||��−��||22(2�)2) 但在t-SNE中我们采用的就是t分布，t分布能够更好地解决拥塞问题，距离接近的点变得更近；距离较远的点变得更远。 �′(��,��)=1(1+||��−��||22)

![](https://gitee.com/hxc8/images0/raw/master/img/202407172045787.jpg)

在这里插入图片描述

## 总结

本文介绍了Unsupervised Learning非监督学习，并且最后附上本文章的思维导图，希望能帮助大家快速地熟悉Unsupervised Learning的运作规律。

![](https://gitee.com/hxc8/images0/raw/master/img/202407172045878.jpg)
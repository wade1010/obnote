## 前言

*接下来将会介绍另外一种网络:生成对抗网络，这种网络在最近十分的流行，不同于之前所学的CNN,RNN，GAN有其独特的旗帜。*

## 一、Pixel RNN

### 1.图片的生成模型

生成模型通过学习样本点的分布，得到联合概率P(X,Y),图像是具有概率分布。我们对图像中原始像素点的离散概率建模，并编码图像整个集的依赖性，从而通过概率分布去预测图片。 无论是Pixel RNN还是Pixel CNN,我们都假设一个像素的值仅取决于它之前的像素的值，即: �(��)=�(��|��−1)�(��−1|��−2)�(��−2|��−3)...�(�2|�1)

### 2.Pixel RNN

传统的Pixel RNN是利用我们前面讲过的LSTM对图片进行处理的。LSTM中一次读取图像的一行，并使用一维卷积层对其进行处理，然后将激活信息馈送到后续层中以预测该行的像素。

![](https://gitee.com/hxc8/images0/raw/master/img/202407172047430.jpg)

在这里插入图片描述

![](https://gitee.com/hxc8/images0/raw/master/img/202407172047452.jpg)

可以看到通过映射后，Row LSTM的感知域是一个三角形区域，并且卷积中要利用先前的状态$h_{t-1}$跟本状态一起卷积得到下一层。 而Diagnoal BiLSTM由于是双向的LSTM，并行计算和捕获任何图像大小的整个可用上下文。每个层的两个方向都以对角线方式扫描图像，从顶部的一个角开始，并到达底部的相反角。计算中的每个步骤一次计算图像中沿对角线的 LSTM 状态，就会得到如图的感知域。

### 3.Pixel CNN

Pixel RNN由于感受野内具有潜在的无边界的依赖范围，会浪费很多的计算成本，但如果我们将感知域扩大后，就可以减少这种情况。 Pixel CNN 使用多个卷积层来保留空间分辨率，不使用池化层。掩码在卷积中采用，以避免看到未来内容。 Pixel CNN中利用 mask 机制，将未来的 context 遮蔽，就实现了随着时间演进的序列模型。

![](https://gitee.com/hxc8/images0/raw/master/img/202407172047167.jpg)

与 PixelRNN 相比，PixelCNN 的并行功能的优势仅在训练或评估测试图像时可用。图像生成过程对于两种网络都是连续的，因为每个采样的像素需要作为输入返回到网络。

## 二、VAE(Variational Autoencoder)

### 1.VAE的优缺点

1. **优点**

1. VAE就生成式模型来说是一种有据可循的方法，它使得查询推断称为可能，如此一来便能够推断出像 这样的分布，这些东西对其他任务来说会是很有用的特征表征。也就是说破除了一定的黑盒性。

1. VAE给隐向量添加了噪声，使得隐向量的编码区域由离散变为连续，扩大了编码区域，减少了隐向量空间的失真点。

1. VAE不仅拥有自编码器的作用(降维)，还可以用于数据的生成。

1. **缺点**

1. VAE从来都没有去学习如何产生一张新的图片，只是保证产生一张与数据库中的图片尽可能相似的而已，VAE做的只是模仿，没有办法产生新的图片。

1. VAE没有使用对抗网络，生成的图片一般都比较模糊

### 2.KL散度

KL散度用来衡量两个分布之间的差异，度量两个概率分布函数之间的“距离”。 ��[�(�)||�(�)]=∑�∈��(�)log⁡�(�)�(�)=��∈�(�)log⁡�(�)�(�) 可以看到KL散度与x是没有关系的，只与他们的概率分布有关。 对数函数是凸函数，所以KL散度的值为非负数，并且可以采用梯度下降去进行优化 很显然，KL散度越小，说明概率 Q 与概率 P 之间越接近，那么估计的概率分布与真实的概率分布也就越接近,所以我们需要尽可能令KL散度为零。 事实上，KL散度并不能表征真正的距离，因为他们不满足互换性，也不满足三角距离不等式。

### 3.隐变量与隐变量模型

- **隐变量:不可直接观测的综合性变量。**

- **隐变量模型： 隐变量模型是一种概率模型，其中某些变量是不可观测的。**

隐变量可以通过数学模型推导出来，但是十分的困难，有些情况下，潜变量和现实中的一些因素是有关系的，而有些情况下指的是抽象概念，例如分类、行为、心理状态、数据结构等等。 使用潜变量的好处之一是潜变量能用来降低数据的维度。大量的观测变量能够被整合起来成为一个潜变量来表示深层次的概念，使得观测数据更容易理解。

![](https://gitee.com/hxc8/images0/raw/master/img/202407172047849.jpg)

在这里插入图片描述

我们可以看到隐变量的维数明显要比其他情况低，事实上模型需要重建压缩数据(见解码器)，它必须学会存储所有相关信息，忽略噪声。这就是压缩的价值所在——它可以让我们去掉任何无关的信息，只关注最重要的特性。训练到最后时，每个图像只有最重要的特征被存储在潜在空间表示中。

### 4.VAE的用途

VAE 模型是一种包含隐变量的生成模型，它利用神经网络训练得到两个函数（也称为推断网络和生成网络），进而生成输入数据中不包含的数据。 VAE 模型在生成多种复杂数据方面已经显示出了巨大的潜力，包括手写数字图像、人脸图像、门牌号图像、CIFAR 图像、场景物理模型、分割图像以及从静态图像进行预测等。

### 5.VAE的结构

VAE其实本质上亦是一种auto-encoder(自编码器)，自编码器是一类在半监督学习和非监督学习中使用的人工神经网络，其功能是通过将输入信息作为学习目标，对输入信息进行表征学习。 AutoEncoder 包括 编码器(Encoder) 和 解码器(Decoder) 两部分。Encoder 过程是将原先的数据（常用于图像方向）压缩为低维向量；Decoder 则是把低维向量还原为原来数据。

![](https://pic4.zhimg.com/80/v2-1547c03a64e4f200902473c9bd67046f_720w.webp)

在这里插入图片描述

VAE生成的不再是简单的特征，而是一个分布，包括均值$\mu$,方差$\sigma$,噪声$e$,噪声$e$是按照正太分布采样出来的。最后生成的特征为 ��=���(��)∗��+�� 避免了自编码器只简单重构原来的特征，导致过拟合，产生不理想的模型泛化能力。加入的噪声，则给模型生成了更多的可能性。 然后在做完Loss Function后，我们还要保证这个式子的最小化: ∑�=13(���(��)−(1+��)+(��)2) 前面半截是为了保证$\sigma_i$的取值一定在零附近，满足高斯分布，因为只有在0附近时$exp(\sigma_i)-(1+\sigma_i)$才会很靠近零，而$m_i$则用于正则化，保证其均值的稳定。

### 6.VAE的实现

VAE中，一般我们的样本先验概率$x$分布是很难直接获取的，那么我们可以假设存在一个与$x$对应的隐式表征$z$的分布是一个先验分布，一般我们设置为高斯分布和其他比较简单的分布.

![](https://pic2.zhimg.com/80/v2-ae2a02ab45d6365dfcd7a77c094b0fbd_720w.webp)

在这里插入图片描述

那么我们在样本生成阶段，我们可以通过标准正态分布采样得到 $z \sim p_{\theta^*(z)}$，然后解码得到样本近似分布，再在此分布上采样来生成样本。其中$\theta^*$是有关于先验假设和条件概率分布的参数，需要我们估计得出。

![](https://pic3.zhimg.com/80/v2-91ce56ff30cf2345ddcbc7da4a4626fa_720w.webp)

在这里插入图片描述

��(�)=∫��(�)��(�|�)�� 但是很明显，我们计算$p(x|z)$的概率分布是非常难获取的，从而导致$p(z|x)$也是十分困难的，所以我们利用$z$这一个假设的隐变量去推出$x$的概率分布也是很困难的。 为了解决这一个问题，我们就需要额外定义一个编码器$q(z|x)$，然后输入$x$，通过$x$的特征推导出某些$z$,从而利用这个$q(z|x)$去迫近我们的$p(z|x)$，然后通过解码器网络把$z$映射到图像$x$

![](https://pic4.zhimg.com/80/v2-6728be496e396bfa87efe331835ab737_720w.webp)

在这里插入图片描述

### 7.VAE的公式推导

由上面内容可以知道我们的损失函数采用的是最大似然函数，这是VAE的核心内容，也是通过EM算法演变而来的，即: �=∑�log⁡�(�)

log⁡�(�)=∫��(�|�)log⁡�(�)��=∫��(�|�)log⁡�(�,�)�(�|�)��=∫��(�|�)log⁡�(�,�)�(�|�)�(�|�)�(�|�)��=∫��(�|�)log⁡�(�,�)�(�|�)��+∫��(�|�)log⁡�(�|�)�(�|�)�� 我们可以观察到后面那一项是我们的KL散度公式:$KL(Q(z|x)||P(z|x))$虽然它的值我们不确定，但是一定是大于等于0的数，我们将前面那一项定义为$L_b$，所以我们的原式可以为： log⁡�(�)≥∫��(�|�)log⁡�(�,�)�(�|�)��

![](https://pic4.zhimg.com/80/v2-0d250c8c3ee48eceae20c8a1e06a072b_720w.webp)

在这里插入图片描述

下面我们队$L_b$继续进行化简: ��=∫��(�|�)log⁡�(�,�)�(�|�)��=∫��(�|�)log⁡�(�|�)�(�)�(�|�)��=∫��(�|�)log⁡�(�)�(�|�)��+∫��(�|�)log⁡�(�|�)��=−��(�(�|�)||�(�))+��∼�(�|�)[log⁡�(�|�)] 从而得出结论:由于散度KL我们需要越接近零越好，所以我们的ELBO最理想情况下就是等于$E_{z\sim Q(z|x)}[\log P(z|x)]$这同时也是最大似然函数的下界。

## 三、GAN(生成对抗网络)

### 1.JS散度

���(�(�)||�(�))=12��(�(�)||�(�))+12��(�(�)||�(�)) 其中$M(x)=\frac{1}{2}(P(x)+Q(x))$，然后我们对JSD的散度公式进行展开: ���(�||�)=12∑�(�)log⁡2�(�)�(�)+�(�)+12∑�(�)log⁡2�(�)�(�)+�(�)=12∑�(�)log⁡�(�)�(�)+�(�)+12∑�(�)log⁡�(�)�(�)+�(�)+log⁡2

![](https://pic3.zhimg.com/80/v2-77829d09d57a249688e876261d1c02a2_720w.webp)

我们可以看到两个分布会在某些点上没有重叠，这时候$P(x)和Q(x)$一定有一个值接近于0，所以JS散度的值会一直保持在log2，这就会导致一个问题，只要两个分布之间存在距离，函数的输出值是一个常数，无法进行梯度下降更新参数。

![](https://pic3.zhimg.com/80/v2-3f338d089b2847399d05071decb2df22_720w.webp)

在这里插入图片描述

- **JS散度与KL散度相比的优点:**

JS散度的值域范围是[0,1]，相同则是0，相反为1。相较于KL，对相似度的判别更确切了。 并且JS散度满足了交换性，克服了KL散度不满足交换性的结果。

### 2.Wasserstein距离

### 1.Wasserstein距离简介

Wasserstein距离也叫做推土机距离（Earth Mover's distance），它从一个分布转换成另外一个分布的过程十分像挖土搬土的过程

![](https://pic1.zhimg.com/80/v2-13d74be3bc3bed2e51ec0f47e4ad88d4_720w.webp)

在这里插入图片描述

### 2.为什么要使用Wassertain距离?

Wasserstein距离相比KL散度、JS散度的优越性在于，即便两个分布没有重叠，Wasserstein距离仍然能够反映它们的远近； KL散度和JS散度是突变的，要么最大要么最小，Wasserstein距离却是平滑的，使用梯度下降法时，KL散度与JS散度都无法计算梯度，而Wassertain距离可以计算梯度 Wasserstein disatnce 的缺点是计算量过大，所以难于计算

### 3.Wassertain距离的公式推导

我们期望将p(x)分布转化为q(x),那我们假设联合分布为$\gamma(x,y)$，转移成本为$d(x,y)$，我们的目的是要找出其最短的Wassertain距离。 �[�,�]=inf�∈∏[�,�]∬�(�,�)�(�,�)���� \begin{equation}         s.t.         \begin{cases} %实现分段函数             \int \gamma(x,y) dy =p(x)\\             \int \gamma(x,y) dx =q(y)\\             \gamma(x,y) \geq0         \end{cases}     \end{equation}\begin{equation}         s.t.         \begin{cases} %实现分段函数             \int \gamma(x,y) dy =p(x)\\             \int \gamma(x,y) dx =q(y)\\             \gamma(x,y) \geq0         \end{cases}     \end{equation} 为了简化计算，我们可以将约束条件与原式子进行整合，并且找出其对偶问题，我们就设两个对偶函数分别为$f(x)$与$g(y)$ �[�,�]=inf�[�,�]≥0∬�(�,�)�(�,�)����+∫�(�)[�(�)−∫�(�,�)��]��+∫�(�)[�(�)−∫�(�,�)��]�� 通过整理得到该距离公式为: �[�,�]=inf�[�,�]≥0∬�(�,�)[�(�,�)−�(�)−�(�)]����+∫�(�)�(�)��+∫�(�)�(�)�� 由于我们需要求最小距离，那么我们在知道$\gamma(x,y) \geq 0$的情况下，必须要保证$[d(x,y)-f(x)-g(y)]\leq0$，从而引出我们的对偶问题: �[�,�]=[sup�,�∫[�(�)�(�)+�(�)�(�)]��|�(�,�)≥�(�)+�(�)] 然后我们的距离公式一般取值为 d(x,y) =$||x-y||$

### 3.GAN的优缺点

- **优点:**

- GAN避免了马尔科夫链式的学习机制(状态转移矩阵)，只用到了反向传播，提高了GAN的效率。

- GAN是一个非常灵活的设计框架，各种类型的损失函数都可以整合到GAN模型当中，理论上只要可微函数都能用于构建生成器和判别器。这样使得针对不同的任务，我们可以设计不同类型的损失函数，都可以在GAN的框架下进行学习和优化。

- 当概率密度不可计算的时候，传统的一些生成模型就不可以工作了。但是GAN在这种情况下依然可以使用，这是因为GAN引入了一个非常聪明的内部对抗的训练机制，可以逼近一些不是很容易计算的目标函数。

- 不依赖任何先验假设。许多方法会假设数据服从某一分布，然后使用极大似然去估计数据分布。

- 采用了生成对抗网络，可以使产生出来的图片更加清晰。

- **缺点：**

- 训练GAN需要达到纳什均衡,有时候可以用梯度下降法做到,有时候做不到

- 它很难去学习生成离散的数据,就像文本

- GAN的可解释性非常差

### 4.GAN的应用领域

GAN的应用领域十分的多，接下来将会挑几个展示一下：

1. 生成图片(生成一些没见过的，虚构出来的图片)

![](https://pic1.zhimg.com/80/v2-d31ef2574b42aba608419605611bc578_720w.webp)

在这里插入图片描述

1. 图像转换(同时实现风格迁移)

![](https://pic3.zhimg.com/80/v2-d15fe08f4b2041676276774e377fbdc6_720w.webp)

在这里插入图片描述

1. 文字-图片转化

![](https://pic1.zhimg.com/80/v2-924800316df9815dbd8a264e093c464c_720w.webp)

在这里插入图片描述

1. 图片编辑(进行图片重构，重建人像图片)

![](https://pic1.zhimg.com/80/v2-4b7f3015355632bac1ccc251ca9fa61c_720w.webp)

在这里插入图片描述

### 5.GAN的基本组成

![](https://pic3.zhimg.com/80/v2-7efb05e94ced8f807938588bfc275eae_720w.webp)

在这里插入图片描述

我们可以看到GAN有两个网络，分别是Generator(生成器)和Discriminator(判别器)组成，GAN的输入是一个随机噪声。

- **生成网络:** 

- **判别网络:** 

### 6.GAN的训练过程

1. 初始化生成器G和辨别器D两个网络的参数。

1. 从训练集抽取n个样本，以及生成器利用定义的噪声分布生成n个样本。固定生成器G，训练辨别器D，使其尽可能区分真假。

1. 循环更新k次辨别器D之后，更新1次生成器G，使辨别器尽可能区分不了真假。

1. 多次更新迭代后，理想状态下，最终辨别器D无法区分图片到底是来自真实的训练样本集合，还是来自生成器G生成的样本即可，此时辨别的概率为0.5，完成训练。

![](https://pic3.zhimg.com/80/v2-d81c6a5411af4268ebdd51d5bf8a3196_720w.webp)

在这里插入图片描述

### 7.GAN的优化

我么前面讲过，可以采用散度这一个数学概念来衡量两个分布之间的距离，GAN生成器中产生的图片与我们真实数据集里面产生的图片其实来源于两个不同的分布，所以我们去进行优化的时候，恰恰也可以利用散度这一个概念去进行优化迫近

![](https://pic3.zhimg.com/80/v2-c9909931653bb0b3215781d1e71824fe_720w.webp)

在这里插入图片描述

可以看到，我们设生成器产生的分布为$P_G$,数据集中抽取的分布为$P_{data}$，那么我们想要获取更好的生成器就需要: �∗=arg⁡min����(��,�����) 前面我们也说过，判别器中，我们需要固定生成器，从而使判别器的输出达到最大，这样就能分辨出生成图片了，下面V函数表征的意思是指分别从数据集Data和生成器G中抽取出的数据之间的距离。

![](https://pic2.zhimg.com/80/v2-c827f78a45e75385c2e5fe7c0a5aac4d_720w.webp)

在这里插入图片描述

�∗=arg⁡max��(�,�) 其中$V(G,D)=E_{y\sim P_{data}}[\log D(y)]+E_{y\sim P_{G}}[\log(1- D(y))]$ 后面计算的过程相对来说比较复杂，所以我们直接给出结论: max��(�,�)=−2log⁡2+2���(�����||��) 这样我们发现每次我们更新参数时，得出的结果是一个常数(因为JS散度在两分布没有交集时一直为0)，这样我们将无法更新我们的参数去调整我们的模型。

### 8.WGAN

所以我们利用前面讲过的Wassertain距离引入了一种方法:**WGAN**，这种方法有效地抑制了JS散度带来的问题。其中加的Lipschitz限制是防止每次变化过大，导致结果不收敛。要保证D平滑地进行优化

![](https://pic2.zhimg.com/80/v2-21e7ba3b94cda5ef82827e0caa61d525_720w.webp)

在这里插入图片描述

max�∈1−�����ℎ���[��∼������(�)−��∼���(�)] 事实上Lipschitz函数是这样的:

![](https://pic2.zhimg.com/80/v2-979350e73044753f3c424c44c0c12065_720w.webp)

在这里插入图片描述

需要满足函数的输出值的变化量小于等于K倍的输入变化量。 除此之外我们有一种进阶版的WGAN(WGAN-GP),它利用限制条件的转化构成新的模型从而达到效果。 max�(��∼������(�)−��∼���(�)−���∼��������[���(0,(||∇��(�)||−1)]) 其中我们的$y\sim P_{penalty}$是指中间的一个连通域

![](https://pic1.zhimg.com/80/v2-81982d1bf830910e65e6bd6704348a10_720w.webp)

在这里插入图片描述

那么我们如何从GAN转换成WGAN呢?

1. 将我们判别器训练中的$\log D(x)$换成$D(x)$

1. 去除sigmoid函数，因为我们的penalty是线性函数

1. 设置我们的weight clipping或者是penalty

1. 将我们生成器训练中目标函数修改成下面这样

![](https://pic4.zhimg.com/80/v2-d3c529a4ed21ee2bf276316a121befaf_720w.webp)

在这里插入图片描述

### 9.Mode Collapse(模式塌陷)

所谓Mode Collapse(模式坍塌)，指的是生成器产生的结果很单一，仅仅只是为了得到最低的判别器损失，却忽视了数据集的分布,这会出现GAN训练生成出来的结果来来去去都是那几个东西。

![](https://pic3.zhimg.com/80/v2-52255b2d3506ef374b6870ab8393371a_720w.webp)

在这里插入图片描述

出现Mode Collapse的原因在数学上十分复杂，简单来说是为了更快的收敛，生成器会倾向于生成一些已经骗过判别器的样本，这样就会像上面一样，一直围绕着一颗星附近进行生成。

### 10.Mode Dropping

所谓Mode Dropping，指 GAN 能很好地生成训练集中的数据，但难以生成非训练集的数据，“缺乏想象力”。因为采样数量的局限性，现实中我们无法采集到全部可能的图像，所以一般采集一定数量的图像来代表整个图像分布。

![](https://pic1.zhimg.com/80/v2-00b6162b9444072c24eb819043ad1118_720w.webp)

在这里插入图片描述

事实上，数据集不能代表整个分布，但是训练时误以为就是整个分布，导致训练来训练去都逃不开这个数据集，导致一定的过拟合。最后的结果就是无论怎么训练，结果都是极其相似的结果，并且很多都是数据集中的内容。

## 四、其他的GAN网络

### 1.Conditional GAN(条件生成对抗网络)

在传统的GAN中，我们输入到生成器G里面的是随机噪声，所以模型无法控制正在生成的数据的模式，这样在判别器中有很多图片可能只是清晰度不够却被判了差的结果，评判的标准不好。但是，通过将附加信息作为条件条件化(conditioning)模型，可以指导数据生成过程。这种条件化可以基于类标签，也可以基于图像修复数据的一部分。

![](https://pic1.zhimg.com/80/v2-8375b23a43b13093597a8bf812ca1b44_720w.webp)

在这里插入图片描述

我们可以看到在Conditional GAN中，我们在生成器中的输入加入了一个特征数据，并且在判决器中也同样加入了同样一个x，这样的输出就不止是0或者1这种单调低效的判别标准，同时还有*red eyes*这一个输出，观察是否与输入的特征值匹配，增加了判别的多样性与准确性。 事实上Conditioanl GAN可以用在很多方面:*text-to-image,image-to-image*都是可以的。

![](https://pic2.zhimg.com/80/v2-895040ce1d5944cd65055b20c615a8fd_720w.webp)

在这里插入图片描述

利用监督学习生成的图片是比较模糊的，我们可以将其与我们的Conditonal GAN结合在一起，那么我们训练之后，就会得到比较清晰的图片。

### 2.Cycle GAN(循环生成对抗网络)

当我们的数据集中，如果输入输出的数学是不成对出现的，那么我们训练出来的结果将很难与输入结果进行匹配，那么就需要引出我们的另外一种GAN网络:**Cycle GAN**

![](https://pic2.zhimg.com/80/v2-2071863d7d6d0410ec3b6edd974cc845_720w.webp)

在这里插入图片描述

所谓的Cycle GAN，其实本质上就是通过一个循环，首先将图像从一个域转换到另一个域，然后，再转回来，如果两次转换都很精准的话，那么，转换后的图像应该与输入的图像基本一致。通过这样的的一个循环，CycleGAN将转换前后图片的配对，类似于监督学习，提升了转换效果。

![](https://pic2.zhimg.com/80/v2-9b628f44c7adf69fea49f2385ee60ad9_720w.webp)

在这里插入图片描述

在Cycle GAN,我们必须要有两个生成器，第一个生成器将原图转换成目标图，第二个生成器是为了避免在判决器时出现清晰图片蒙混过关的问题时(由于是不配对的图片，所以无法使用前面的conditional GAN)，将已经生成的图片重新生成原图，这样本质上其实完成了一次匹配。

### 3.Energy-based GAN (EBGAN)

![](https://pic4.zhimg.com/80/v2-42965e60f35d4f7aa8ed5a71904ad6db_720w.webp)

在这里插入图片描述

这种GAN模型，将我们的判别器换成了一个Autoencoder，这就允许了判别器可以进行预训练(不需要利用真实的照片)，大大提高了判别器的训练速度。

## 总结

本文介绍了GAN 生成对抗网络，并且最后附上本文章的思维导图，希望能帮助大家快速地熟悉GAN的运作规律。

![](https://pic1.zhimg.com/80/v2-4f4a19ddb095ff4ea9817ff550540e5c_720w.webp)
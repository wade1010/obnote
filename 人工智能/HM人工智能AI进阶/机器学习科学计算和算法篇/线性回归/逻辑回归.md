逻辑回归（Logistic Regression）是机器学习中的**一种分类模型**，逻辑回归是一种分类算法，虽然名字中带有回归。由于算法的简单和高效，在实际中应用非常广泛。

## 1 逻辑回归的应用场景

- 广告点击率

- 是否为垃圾邮件

- 是否患病

- 金融诈骗

- 虚假账号

看到上面的例子，我们可以发现其中的特点，那就是都属于两个类别之间的判断。逻辑回归就是解决**二分类**问题的利器

## 2 逻辑回归的原理

要想掌握逻辑回归，必须掌握两点：

- 逻辑回归中，其输入值是什么

- 如何判断逻辑回归的输出

### 2.1 输入

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143124.jpg)

逻辑回归的输入就是一个线性回归的结果。

### 2.2 激活函数

- sigmoid函数

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143963.jpg)

- 判断标准

	- 回归的结果输入到sigmoid函数当中

	- 输出结果：[0, 1]区间中的一个概率值，默认为0.5为阈值

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143653.jpg)

逻辑回归最终的分类是通过属于某个类别的概率值来判断是否属于某个类别，并且这个类别默认标记为1(正例),另外的一个类别会标记为0(反例)。（方便损失计算）

输出结果解释(重要)：假设有两个类别A，B，并且假设我们的概率值为属于A(1)这个类别的概率值。现在有一个样本的输入到逻辑回归输出结果0.55，那么这个概率值超过0.5，意味着我们训练或者预测的结果就是A(1)类别。那么反之，如果得出结果为0.3那么，训练或者预测结果就为B(0)类别。

关于**逻辑回归的阈值是可以进行改变的**，比如上面举例中，如果你把阈值设置为0.6，那么输出的结果0.55，就属于B类。

**在之前，我们用最小二乘法衡量线性回归的损失**

**在逻辑回归中，当预测结果不对的时候，我们该怎么衡量其损失呢？**

我们来看下图(下图中，设置阈值为0.6)，

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143556.jpg)

那么如何去衡量逻辑回归的预测结果与真实结果的差异呢？

## 3 损失以及优化

### 3.1 损失

逻辑回归的损失，称之为**对数似然损失**，公式如下：

- 分开类别：

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143661.jpg)

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143534.jpg)

为预测值对应的概率值。

怎么理解单个的式子呢？这个要根据log的函数图像来理解

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143256.jpg)

无论何时，我们都希望**损失函数值，越小越好**

分情况讨论，对应的损失函数值：

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143083.jpg)

- 综合完整损失函数

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143948.jpg)

接下来我们呢就带入上面那个例子来计算一遍，就能理解意义了。

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143770.jpg)

我们已经知道，-log(P), P值越大，结果越小，所以我们可以对着这个损失的式子去分析

### 3.2 优化

同样使用梯度下降优化算法，去减少损失函数的值。这样去更新逻辑回归前面对应算法的权重参数，**提升原本属于1类别的概率，降低原本是0类别的概率。**

## 4 小结

- 逻辑回归概念【知道】

	- 解决的是一个二分类问题

	- 逻辑回归的输入是线性回归的输出

- 逻辑回归的原理【掌握】

	- 输入：

		- 线性回归的输出

	- 激活函数

		- sigmoid函数

		- 把整体的值映射到[0,1]

		- 再设置一个阈值，进行分类判断

- 逻辑回归的损失和优化【掌握】

	- 损失

		- 对数似然损失

		- 借助了log思想，进行完成

		- 真实值等于0，等于1两种情况进行划分

	- 优化

		- 提升原本属于1类别的概率，降低原本是0类别的概率。

# 逻辑回归api介绍

- sklearn.linear_model.LogisticRegression(solver='liblinear', penalty=‘l2’, C = 1.0)

	- solver可选参数:{'liblinear', 'sag', 'saga','newton-cg', 'lbfgs'}，

		- 默认: 'liblinear'；用于优化问题的算法。

		- 对于小数据集来说，“liblinear”是个不错的选择，而“sag”和'saga'对于大型数据集会更快。

		- 对于多类问题，只有'newton-cg'， 'sag'， 'saga'和'lbfgs'可以处理多项损失;“liblinear”仅限于“one-versus-rest”分类。

	- penalty：正则化的种类

	- C：正则化力度

> **默认将类别数量少的当做正例**


**LogisticRegression方法相当于 SGDClassifier(loss="log", penalty=" "),SGDClassifier实现了一个普通的随机梯度下降学习。而使用LogisticRegression(实现了SAG)**

# 癌症分类预测-良／恶性乳腺癌肿瘤预测

下面是notebook的代码

```
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report,roc_auc_score

# 1.获取数据
names = ['Sample code number', 'Clump Thickness', 'Uniformity of Cell Size', 'Uniformity of Cell Shape',
                   'Marginal Adhesion', 'Single Epithelial Cell Size', 'Bare Nuclei', 'Bland Chromatin',
                   'Normal Nucleoli', 'Mitoses', 'Class']

data = pd.read_csv("https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data",
                  names=names)
data.head()

data = data.replace(to_replace='?',value=np.NaN)
data = data.dropna()

# 确定特征值，目标值
x = data.iloc[:,1:10]
x.head()

y = data['Class']
y.head()

# 分割数据
x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2,random_state=22)

# 特征工程-标准化
transfer = StandardScaler()
x_train = transfer.fit_transform(x_train)
x_test = transfer.fit_transform(x_test)

# 4.机器学习(逻辑回归)
estimator = LogisticRegression()
estimator.fit(x_train,y_train)

# 5.模型评估
# 5.1 基本评估
y_predict = estimator.predict(x_test)
print(y_predict)
score = estimator.score(x_test,y_test)
score

# 5.2 其它评估
ret = classification_report(y_test,y_predict)
print(ret)
# 5.2 其它评估-加上参数
ret = classification_report(y_test,y_predict,labels=(2,4),target_names=('良性','恶性'))
print(ret)

# 不平衡二分类问题评估方法 
y_test = np.where(y_test>3,1,0)
roc_auc_score(y_true=y_test,y_score=y_predict)
```

# 3.4 分类评估方法

## 1.分类评估方法

### 1.1 精确率与召回率

#### 1.1.1 混淆矩阵

在分类任务下，预测结果(Predicted Condition)与正确标记(True Condition)之间存在四种不同的组合，构成混淆矩阵(适用于多分类)

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143821.jpg)

#### 1.1.2 精确率与召回率

- 精确率(Precision)：预测结果为正例样本中真实为正例的比例（了解）

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143712.jpg)

- 召回率(Recall)：真实为正例的样本中预测结果为正例的比例（查得全，对正样本的区分能力）

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143659.jpg)

### 1.2 F1-score

还有其他的评估标准，F1-score，反映了模型的稳健型

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143679.jpg)

### 1.3 分类评估报告api

- sklearn.metrics.classification_report(y_true, y_pred, labels=[], target_names=None )

	- y_true：真实目标值

	- y_pred：估计器预测目标值

	- labels:指定类别对应的数字

	- target_names：目标类别名称

	- return：每个类别精确率与召回率

```python
ret = classification_report(y_test, y_predict, labels=(2,4), target_names=("良性", "恶性"))
print(ret)
```

**假设这样一个情况，如果99个样本癌症，1个样本非癌症，不管怎样我全都预测正例(默认癌症为正例),准确率就为99%但是这样效果并不好，这就是样本不均衡下的评估问题**

问题：**如何衡量样本不均衡下的评估**？

## 2 ROC曲线与AUC指标

### 2.1 TPR与FPR

- **TPR = TP / (TP + FN)**

	- **所有真实类别为1的样本中，预测类别为1的比例**

- **FPR = FP / (FP + TN)**

	- **所有真实类别为0的样本中，预测类别为1的比例**

### 2.2 ROC曲线

- ROC曲线的横轴就是FPRate，纵轴就是TPRate，当二者相等时，表示的意义则是：对于不论真实类别是1还是0的样本，分类器预测为1的概率是相等的，此时AUC为0.5

![](https://gitee.com/hxc8/images1/raw/master/img/202407172143803.jpg)

### 2.3 AUC指标

- AUC的概率意义是随机取一对正负样本，正样本得分大于负样本得分的概率

- AUC的范围在[0, 1]之间，并且越接近1越好，越接近0.5属于乱猜

- AUC=1，完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。

- 0.5<AUC<1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。

### 2.4 AUC计算API

- from sklearn.metrics import roc_auc_score

	- sklearn.metrics.roc_auc_score(y_true, y_score)

		- 计算ROC曲线面积，即AUC值

		- y_true：每个样本的真实类别，必须为0(反例),1(正例)标记

		- y_score：预测得分，可以是正类的估计概率、置信值或者分类器方法的返回值

```python
# 0.5~1之间，越接近于1约好
y_test = np.where(y_test > 2.5, 1, 0)

print("AUC指标：", roc_auc_score(y_test, y_predict)
```

- AUC只能用来评价二分类

- AUC非常适合评价样本不平衡中的分类器性能

## 3 小结

- 混淆矩阵【了解】

	- 真正例（TP）

	- 伪反例（FN）

	- 伪正例（FP）

	- 真反例（TN）

- 精确率(Precision)与召回率(Recall)【知道】

	- 准确率：（对不对）

		- （TP+TN）/(TP+TN+FN+FP)

	- 精确率 -- 查的准不准

		- TP/(TP+FP)

	- 召回率 -- 查的全不全

		- TP/(TP+FN)

	- F1-score

		- 反映模型的稳健性

- roc曲线和auc指标【知道】

	- roc曲线

		- 通过tpr和fpr来进行图形绘制，然后绘制之后，行成一个指标auc

	- auc

		- 越接近1，效果越好

		- 越接近0，效果越差

		- 越接近0.5，效果就是胡说

	- 注意：

		- 这个指标主要用于评价不平衡的二分类问题


![](https://gitee.com/hxc8/images7/raw/master/img/202407190027978.jpg)



![](https://gitee.com/hxc8/images7/raw/master/img/202407190027967.jpg)









分布式事务讲解



![](https://gitee.com/hxc8/images7/raw/master/img/202407190027695.jpg)



一般是垂直切分 也就是按业务分库



atomikos





![](https://gitee.com/hxc8/images7/raw/master/img/202407190027647.jpg)



atomiks 解决分布式事务原理 如下



![](https://gitee.com/hxc8/images7/raw/master/img/202407190027934.jpg)







有中间的协调器





两阶段提交的过程:



为什么说众两阶段提交协议可以帮我们解决这种跨库事务问题的好，我给你俩画一个简单的图，给您的分析一下。是这么回事儿，我们看两阶段提交协议什么意思啊？我们刚说了有可能我我这一个。支付的操作，对吧？他跨库操作有可能支付操作操作订单库的时候改订单的状态改成功了，但是库存库可能减，库存失败了，对啊。减库存失败原因很多，有可能再度重铺就挂了，或者说库存的那个表里面数据不够减啊。对吧，都有可能，或者说减库存的时候它网络中断了。网络断了是不是都有可能导致我颈部存这一步操作失败，那从而我们说之前的操作订单库的内部操作，修改订单状态以及食物已经提交啦。但是没法回滚的或者说很难回滚，但有的同学说哎我写个脚本回滚，那这个这个就另说了，就这个很难啊，因为有可能你的订单状态后面又发生变化了，对吗？也就是说咱们刚说的这种情况，就订单库事务已经提交了，那基本上库存库挂了之后，那订单部基本上那个事务是没法回滚的，但是我们说我们用我们的两阶段也就2PC两阶段提交协议啊，是可以帮我们解决这么多。中跨库数问题，那注意注意。



那注意注意看，我现在来给你解释一下什么叫两阶段提交协议，追我给你敲一下黑板，这个地方是面试，可能经常会问到你的。二等于一个题目他会问你哎两天问题要协议你有碰到过吗？你又解决过类似于相关的事物问题吗？好，那来我那我就来给你讲一下大概应该怎么去解决，怎么去回答。他两阶段提交协议啊，帮我解决中花哭诉，问一下大概是这么一个原理，是什么原理啊？爷爷说我们有一个中间的一个一个东西，诶，中间的一个裁判，那是一个裁判的一个组件，就是我们的相当于我们的协调性。就相当于我们一个协调器，叫事务协调器，也就中间的协调者。有，如果如果有同学知道什么是zookeeper有点类似这样的一个中间那个协调器，然后是这样，就我们一个订单。刚刚那个支付回调令操作，他是这么来做，我们第一步肯定是操纵订单库，修改订单状态，我们修改完订单状态之后告诉你。不要马上提交事务commit，而是执行完那条修改订单状态sql之后把你执行成功的结果，就是只要你不报错，



你就把你执行成功的结果告诉给协调去注意告诉给协调器。注意这时候没有commit事务，然后我再去操作我们库存库去减库存，然后操作成功之后也就操作成功，就是把我们的库存的那一条减库存的那条SQL执行完，执行完了之后把这个执行完SQL的结果也就是吧，要么执行成功，要么失败都会执行SQL的结果告诉给我们的协调器，OK，这是我们的第一阶段操作。一阶段操作一阶段。





咱们先把我们的不同库的那个SQL先预执行一下，但是我不提交事务，之前 咱们是先提交事务，先提交订单库的事务吧。然后再执行库存库相关的SQL吧，但是咱们现在不这么做。



 第一阶段，先把所有的跨库的一些个SQL先执行完，但是我不提交事务。如果我两个操作中，两个库的SQL都执行完成，都没有任何报错，我告诉给协调期的都是执行成功，我在第一阶段两个跨库的操作SQL都执行成功，OK，这时候由我们的协调器。通知我们每个订单库通知我们之前的每一个来提交事务。执行真正的commit，也就把咱们刚刚的那每个库执行的SQL做个真正的提交，这就是第二阶段的操作。



那第一阶段如果订单不成功，我我操作库存不失败怎么办呢？那很简单呐，协调器他收到，但凡有一个操作失败，在第一阶段，但凡有一个操作失败。我第二阶段执行的肯定就是rollback。对吧，因为我第一阶段都没有把事务提交，他当然可以rollback啦



比方说出现这么一种场景，就我第一阶段两个都是执行成功，我第2个阶段我的协调器通知两个库把对应的自行执行的效果都去commit的时候，有可能出现这么一种场景，就是咱们提交订单库提交成功了，然后提交我们的库存库，是不是有可能提交失败对吧？那这不这不是又回到咱们刚那个问题上面了吗？好确确实实存在这么一种场景，我要告诉你这种时候他会怎么做呢，他会这么来做,这协调期啊，当你在提交订单不成功之后再去提交，过程不失败，OK，协调器他会重试，我不知道同学们理解这个概念吗？他会试着重新再去提交一次 ，如果不成功他要继续重试，可能重试了5 6次，比方说重重试重试了5次还不成功，那没办法，那这时候可能就真的不成功了，那他会怎么操作呢？他会记一个日志，然后可能后台有定时任务再去重试，如果定时任务重试再c重试还不成功，没办法这时候只有人工来介入啊。





---

两阶段都加锁，也没完全解决  分布式事务不可能百分之百解决，只是尽可能提高解决概率。提高事务一致性概率。

![](https://gitee.com/hxc8/images7/raw/master/img/202407190027582.jpg)



![](https://gitee.com/hxc8/images7/raw/master/img/202407190027319.jpg)





按时间渐变性重试 1s 5s 30s 5min  1小时    还是不成功就记录日志 来重试，还不成功  只能人工了。大型互联网公司就有这么一批人做着工作





---



---



---



上面是夸库  但是如果是微服务 需要跨平台跨系统(微服务)

大型互联网是这么解决的



先了解两个理论



![](https://gitee.com/hxc8/images7/raw/master/img/202407190027130.jpg)



![](https://gitee.com/hxc8/images7/raw/master/img/202407190027567.jpg)





# 柔性事务

![](https://gitee.com/hxc8/images7/raw/master/img/202407190027151.jpg)





![](https://gitee.com/hxc8/images7/raw/master/img/202407190027852.jpg)



TCC解决方案它也是一种两阶段的解决方案。他把我们的一个订单支付的一个操作啊，也就我们调动这几个微服务操作，它分为了两阶段，注意分为了两个阶段，你看这是阶段一这是阶段，二第一阶段注意看我一个支付回调操作，调到我订单服务之后，我们之前说是要把订单改成以支付状态吧，对吧，好，但是我们用tcc这种方案之后啊，那实际上就不再是把我们订单状态改成已支付了，而是把这个订单状态改成更新中，注意改成更新中好，然后再去由我们订单服务调用，我们的在第一阶段的时候调入我们库存服务的时候，第2个我们库存服务的接口的时候，注意它是把我们的库存给冻结，并不是真的减掉

，然后调用我们积分服务接口的时候，它并不是真正的加积分，而是预加积分预加积分是什么意思啊？可能是可能有的同学不理解 什么意思啊就唉我这里有一个积分字段 注意，我原来这里有一个积分字段对不对？我们之前说的，如果你加了积分之后你加的积分这比方说我原来有一个有积分是10个我现在又支付了一个订单，它加一个积分那是不是变成11啊，那我直接就在积分这个阶段上面去加对不对，但是我现在用这么两阶段事物去操作之后我第一阶段去调用积分服务的时候，我不是在积分这个阶段去加一个积分了  我是再搞了一个预加积分字段，加到这上面。



接下来我会调用仓储服务的一个接口，我们原来调用仓库服务接口是直接生成已生效的出货单，对不对，好，这时候我调用仓储服务的接口，注意我我创建了出库单，但是你看草稿状态草稿状态是还不能出库的，注意看是不能出库的，然后这是我第一阶段我做的事情，然后第2阶段干嘛，第2个阶段我是这么来做，如果你第一阶段这每一个服务的操作都成功了，OK，我这时候我会调用我第二阶段每一个服务的另外一个接口叫做conform接口，针对这一个支付业务的另外一个接口，注意我们刚刚这是一个API对不对。



这是一个API对不对一个APM每一个服务都有都有一个API吗？对吧，这是第1个API注意，你看我们这里我们正用这种T CC这种事物解决方案，他会开发开发三个API1，这是我们刚刚说的第1个API对不对？然后这第2个API API第2个很放的API调用的场景是什么？当我们所有第一阶段所有API都调动成功之后，也许说白了第一阶段你会发现像一个什么样的效果啊？就第1个阶段你是不是发现了感觉跟咱们之前说的两阶段提交前列第1阶段很类似啊，是不是预先的尝试一下锁定一下我们相关的一些资源对不对？



或者说来来验证一下或者说试探着看一下我们每个服务是否都正常，每一个服务相关的一些数据库啊，或者说第三方操作中间件是否都正常，如果都正常，这几个服务是不是都应该成功啊？成功的话第二阶段我做什么操作要用我每一个服务对应的第2个API叫做confirm的API注意，这是第2个接口啊，我要开发几个接口的  注意，我要开发好几个接口的 这一个接口，做什么操作调用我们订单服务的时候，直接把我订单状态应该改成什么状态，应该改成已支付。



没错，改成已支付嘛，这时候就完结嘛，对吧？那然后再去调用库存服务，这时候干嘛？是不是就应该把之前冻结的库存真正给减掉啊，然后再调用我们积分，不不注意这时候调用积分服务的confirm API做什么操作，就是把这之前我们预加积分的那一个1加到我们积分字段，也就这时候积分变成11了，然后预加积分的字段变成0了，你会发现是不是类似于我们第2阶段真正的去把这些资源完全提交掉啊，然后再调用我们仓储服务的可控的confirmAPI ，做什么操作，就是把我们的之前的第一阶段生成了草稿状态的出库单改成什么状态改成生效状态你就可以发货了





那很多同学可能要有疑问，那就是cancel，什么意思啊？那我讲到这里，如果你前面听懂我讲的那个2pc，这个看起来还用我去解释吗？无非就是唉，第一阶段某一调用，我们这每一个服务的某一个API，如果失败了，那是不是第2阶段就不再是调某每一个服务的conform的API了，是不是就就应该调用我们第3个API我们的看守劈I刊上的接口注意我刚说了吗？这种T CC这种解决方案，他每一个服务啊针对某一个特定的业务场景，他要开发三个API第1个是预留资源的API，第2个是confirm的API，第3个是我们的cancel API



cancel 就是回滚操作  如下图

![](https://gitee.com/hxc8/images7/raw/master/img/202407190027258.jpg)







如果出现下面问题  



![](https://gitee.com/hxc8/images7/raw/master/img/202407190027861.jpg)







![](https://gitee.com/hxc8/images7/raw/master/img/202407190027431.jpg)





---



---



---



---



---

# TCC和2PC解决方案本质区别



2PC适用并发不高，因为全程是大事务，锁表。并发低比较适合



TCC是将大事务分解成小事务。但是写的接口多，每个服务都要写 try  confirm 和cancel 3个接口  并发不高并不适合，反而变慢
项目亮点-生产环境到底如何解决分布式事务极端情况挑战与兜底！

  

![](https://gitee.com/hxc8/images7/raw/master/img/202407190026557.jpg)

如果异步线程挂掉

那对于上游客户端来说，那可能就是超时

那可能救会出现两种情况：

1、异步线程可能执行成功

2、异步线程可能执行失败

那对于上游来说，它是认为这个库存到底有没有扣减成功，它是不知道的

所以上游的订单状态，它变成已扣减或者没有扣减，这个都是有问题的。

所以要搞清楚这个问题，本质上就是一个分布式事务问题。

事务 ACID

在分布式事务下，更多的强调它的原子性

分布式事务，有隔离性问题，但是这个问题在绝大部分的场景是不去考虑的，这种问题也不是说不能解决，只是你解决它的成本可能比这个问题本身更加的复杂，其实是得不偿失的。

分布式事务，在业界其实没有一个非常完美的解决方案。

接下来讲下在业务当中是怎么去权衡取舍的，

在一个没有网络隔离的本地事务，它是由内存总线和数据库的一个连接，去保证它本地事务的一个原子性.

但是在分布式场景，由于这个网络隔离的不可靠性，它没有办法去协调同步各个节点的成功失败的状态。

说到协调，就需要引入一个协调器，它去做两件事，就是同步多个节点它们之间的状态和统一它们的行为就是要么一起成功要么一起失败

当然这个时间不是严格意义上的“同时”,它肯定是有一个先后关系的，  这也是弱一致性的由来。

节点的同步类型也分两种：

阻塞式和非阻塞式，简单理解就是它们一致性的这个时间的开销和它们资源的一个消耗的对比。

互联网业务场景，大部分情况下对于性能的要求，往往比一致性要求更高，所以我们一般采用的还是弱一致性的解决方案。

就是尽量避免某一个节点它可能网络不稳定，导致其他节点的资源都被锁定了的这种情况，因为这种情况往往导致性能急剧下降。

那对于多节点的这种行为上的同步，其实就两种情况，要么全部成功，要么全部失败。

比如协调多个节点去执行本地事务，那其中一个节点失败，那是把之前的事务都回滚呢？还是让后面的事务不断的去重试呢？

这个要具体看你的业务了。

比如说下单的链路，它包含订单的更新和库存的扣减，比如先更新订单的状态，让后再去扣减库存，那库存扣减失败了，那我不断的再去重试，这个其实意义不大，因为本身可能就没有库存了，再怎么重试也是没有库存的，只会增加系统的开销，这种情况一般采用回退的机制，把这个订单状态回滚回去，相比不断的去扣减这个已经不存在的库存，这个回滚成功的概率会更高一些。

另外一种是努力通知型，就是让后面的节点不断的去重试，比如说物流服务，我们发完货了，订单状态要更新，比如说发货它已经执行成功了，我们更新订单可能因为网络原因超时，那我们不断的去重试，这个是没有问题的，因为更新这个状态，它其实是没有什么资源的竞争的。适合不断重试，达到最终一致性。

如果遇到一些非业务上的一些错误，比如说网络超时，那这种情况怎么去解决呢？可以参考seata ，每一个节点，它都有一个本地事务提交表，它这个流水表相当于记录了每一次事务提交它的一个唯一标识，根据这个标识，不管是回退还是重试，都可以根据这个流水表来。
```
#include <stdio.h>
using namespace std;

void test()
{
    short i = -65537;
    int j = i + 1;
    printf("i = %d,j = %d\n", i, j);

    int x = -65537;
    unsigned int y = 0XFFFEFFFF;
    if (x == y)
    {
        printf("相等\n");
    }
    else
    {
        printf("不相等\n");
    }
}
int main()
{
    test();
    return 0;
}


```

1 万能法:

补码 = 反码 + 1   补码的补码就是原码

原码:  一个整数  按照绝对值的大小转化为二进制数

0000 0000 0000 0001 0000 0000 0000 0001 原码

1111 1111 1111 1110 1111 1111 1111 1110 反码

1111 1111 1111 1110 1111 1111 1111 1111 补码 (反码+1)  转成16进制 0XFFFEFFFF

short 占2个字节所以 0XFFFEFFFF 高位就会丢失,那么其实它就是0XFFFF

i = 0xffff , 对于我们的有符号数而言,最高位是符号位

1 111 1111 1111 1111

最高位是符号位,就不用看

1 111 1111 1111 1111 原码

1 000 0000 0000 0000 反码

1 000 0000 0000 0001 补码

上面的补码 1表示负号,后面就是的也是1(000 0000 0000 0001),最终就是-1

2 周期函数法:

-65537 = (-1) * 65536 - 1    结果也就是 -1

 */
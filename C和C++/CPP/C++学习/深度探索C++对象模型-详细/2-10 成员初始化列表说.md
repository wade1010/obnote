（1）何时必须用成员初始化列表？

a)如果这个成员是引用

b)如果这个成员是const类型

c)如果这个类似继承一个基类，并且基类中有写构造函数，这个构造函数里面还有参数

d)如果成员变量类型是某个类，而这个类写的构造函数是带参数的

（2）使用初始化列表的优势

除了必须用初始化列表的场合，我们使用初始化列表还有什么其它目的？

有，提高程序运行效率。

部分代码：

```
class A
{
public:
    X xobj; // X类对象,此示例代码省略了
    int m_a;

    // 构造函数
    A(int tmpvalue) // 这里够早了xobj,耗费了一调用构造函数的机会
                    // 站在编译器视角,代码如下
                    // X xobj;  xobj.X::X();
    {
        xobj = 1000; // 构造一个临时对象,把临时对象内容给了xobj,释放掉临时对象 ,这一行导致3个动作
                     // 站在编译器的角度
                     // X tmpobj;//生成一个临时对象;
                     // tmpobj.X::X(1000);//临时对象调用构造函数
                     // xobj.X::operator=(tmpobj); //xobj调用拷贝赋值运算符
                     // tmpobj.X::~X();//调用析构函数回收对象
                     //
        m_a = 500;
    }
};
```

上面代码消耗巨大，可以使用初始化列表来优化

```
class A
{
public:
    X xobj; // X类对象,此示例代码省略了
    int m_a;

    // 构造函数
    A(int tmpvalue) : xobj(1000) // 站在编译器视角
                                 // X xobj;
                                 // xobj.X::X(1000);
    {
        m_a = 500;
    }
};
```

对于类型成员变量xobj放到初始化列表中能够比较明显的看到效率的提升

但是如果是个简单类型的成员变量，比如 int m_a，其实放在初始化列表或者放在函数体里效率差别不大。

提醒：成员变量初始化尽量放在初始化列表里。

（3）初始化列表细节探究

说明：

3.1 初始化列表中的代码可以看作是被编译器安插到构造函数中的，只是这些代码有些特殊；

3.2 这些代码，是在任何用户自己代码之前执行的

3.3这些初始化列表中变量的初始化顺序是 定义的顺序，而不是在初始化列表中的前后顺序，

不建议在初始化列表中进行，两个都在初始化列中出现的成员之间的初始化，代码如下

```
class A
{
public:
    int m_a;
    int m_b;

    // 构造函数
    A(int tmpvalue) : m_b(100), m_a(m_b)//错误的，程序不报错，但是m_a的结果错误
    {
    }
};
```
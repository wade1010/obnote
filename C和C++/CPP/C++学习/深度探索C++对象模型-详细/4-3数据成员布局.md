（1）观察成员变量地址规律

普通成员变量的存储顺序，是按照在类中的定义顺序从上到下。

比较晚出现的成员便来那个在内存中有更高的地址

（2）边界调整，字节对齐

某些因素会导致成员变量之间排列不连续，就是边界调整（字节对齐），调整目的是提高效率，编译器自动调整。

调整：往成员之间填补一些字节，使用类对象的sizeof字节数凑成一个4的整数倍或者8的整数倍。

#pragma pack(1) //指定对齐 

class A{

......

};

#pragma pack   //取消指定对齐，恢复缺省对齐

为了统一字节对齐问题，引入一个概念叫一字节对齐（不对齐）；

有虚函数时，编译器往类定义中增加vptr虚函数表指针：内部的数据成员。

（3）成员变量偏移值的打印

成员变量偏移值，就是这个成员变量的地址离对象首地址偏移多少。

方式1：

printf("m_a=%d\n",&MyClass::m_a);

printf("m_b=%d\n",&MyClass::m_b);

printf("m_c=%d\n",&MyClass::m_c);

方式2：

定义一个宏

#define GET(A,m) (int)(&((A*)0)->m)

cout<< GET(MyClass,m_a)<<endl;
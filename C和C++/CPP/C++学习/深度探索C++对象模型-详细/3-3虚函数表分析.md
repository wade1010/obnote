(1)一个类只有包含虚函数才会存在虚函数表，同属于一个类的对象共享虚函数表，但是各自vptr（虚函数表指针），当然所指向的地址（虚函数表首地址）相同。

(2)父类中有虚函数就等于子类中有虚函数，换句话说，父类中有虚函数表，则子类中肯定有虚函数表，因为你是继承父类的。

也有人认为，如果子类中把父类的虚函数的virtual关键字去掉，是不是这些函数就不再是虚函数了？

错误，只要在父类中是虚函数，那么子类中即便不写virtual，也依旧是虚函数。

但不管父类还是子类，都只会有一个虚函数表，不能认为子类中有一个虚函数表+父类中有一个虚函数表，从而得到一个结论：子类中有两个虚函数，这是错误的。

虚函数表跟着类走，虚函数表指针跟着对象走

子类中是否可能会有多个虚函数表？后续讲解。（多重继承）

（3）如果子类中完全没有虚函数，则我们可以认为子类的虚函数表和父类的虚函数表内容相同。

但仅仅是内容相同，这两个虚函数表在内存中处于不同位置，换句话来说，这只是内容相同的两张表。

虚函数表中每一项，保存着一个虚函数的首地址，但如果子类的虚函数表某项和父类的虚函数表某项代表同一个函数（这表示子类没有覆盖父类的虚函数）

则该表项所执行的该函数的地址应该相同。

(4）超出虚函数表部分内容不可知。

直接用子类对象给父类对象赋值，子类中的属于父类那部分内容会被编译器自动区分（切割）出来并拷贝给了父类对象。

所以 Base base = derive;实际上干了两个事情：

1）生成一个base对象

2）用derive来初始化base对象的值。

这里编译器给我们做了一个选择，想让derive初始化base对象的时候，derive的虚函数表指针值并没有覆盖base对象的虚函数表指针值，编译器帮我们做到了这点。

```
#include <iostream>
using namespace std;
class P
{
public:
    virtual void show(int a)
    {
        std::cout << "P show(int a)" << std::endl;
    }
    void hello()
    {
        std::cout << "P hello" << std::endl;
    }
};

class S : public P
{
public:
    void show(int a)
    {
        std::cout << "S show(int a)" << std::endl;
    }
    void show(short b)
    {
        std::cout << "sfsd" << std::endl;
    }
    void hello()
    {
        std::cout << "S hello" << std::endl;
    }
};
void test()
{
    S s;
    P p = s;
    p.hello();
    p.show(1);
}
int main()
{
    test();
    return 0;
}
输出如下：
P hello
P show(int a)
```

OO（面向对象） OB（基于对象）概念：

C++通过类的指针和引用来支持多态，这是一种程序设计风格，这就是我们常说的面向对象，object-oriented model；

OB（object-based），也叫ADT抽象数据模型（abstract datatype model），不支持多态，执行速度更快，因为函数调用的解析不需要运行时决定（没有多态），而是编译期间解析完成，内存空间紧凑程度上跟紧凑，因为没有虚函数表指针和虚函数表概念。

很显然,OB的设计灵活性差

C++既支持面向对象程序设计（继承 多态），也支持基于对(OB)程序设计。

 
![](https://gitee.com/hxc8/images2/raw/master/img/202407172213326.jpg)

Point pt;

sizeof(pt) = 16

![](https://gitee.com/hxc8/images2/raw/master/img/202407172213512.jpg)

一个实例化对象包括非静态成员变量，当一个类里面有虚函数的时候，一个实例化对象里面会有虚表指针，同时对象中还可能为字节对齐而必须的填充。静态函数和成员函数不放在pt里面，C++这样规定的考虑是什么？

两个方法，1 函数调用效率  2 实例化对象的大小。

假如用另外一种方式，假如把每个函数的地址都放在pt对象中，当你成员函数越来越多的时候，对象就对来越大，我们当然没有必要，因为函数只存在一份，对象会有多个，我们干嘛在每个对象里面都存放函数的地址，这是处于内存空间的考虑。

调用非虚函数和普通函数的效率是没有差异的，通过多态的方式调用虚函数和直接调用虚函数不一样，只有通过多态的方式调用虚函数的时候效率稍微低一些，因为中间经过了一层虚表，通过虚表指针找到虚表，再找到函数的地址才能调用。

>一个实力对象中包含非静态数据成员、虚表指针以及为对齐而必须得填充，静态成员变量、函数独立于单个实例化对象。

![](https://gitee.com/hxc8/images2/raw/master/img/202407172213982.jpg)

  

![](https://gitee.com/hxc8/images2/raw/master/img/202407172213713.jpg)

![](images/WEBRESOURCEbc0c0acbd5f7949352ee0b9a56a2aebd截图.png)

![](images/WEBRESOURCEc78f21b48f7d7c27aee0c1f251a074ba截图.png)

![](https://gitee.com/hxc8/images2/raw/master/img/202407172214029.jpg)

这里介绍的继承都是public继承

![](https://gitee.com/hxc8/images2/raw/master/img/202407172214423.jpg)

mac 上 clang 和g++ 测试，都是8字节

![](https://gitee.com/hxc8/images2/raw/master/img/202407172214816.jpg)

![](https://gitee.com/hxc8/images2/raw/master/img/202407172214202.jpg)

![](images/WEBRESOURCEf986579a5ba397baa1a9137f18884993截图.png)

一个父类的指针，可以指向父类的对象，也可以指向它的任何一个子类的对象，当使用该指正调用虚函数的时候，它会根据具体所指对象的类型，来决定调用哪个虚函数。

上图表示多态在C++中是如何实现的。

Point3D重写了print这个虚函数，编译器也为Point3D合成了虚的析构函数。所以无论是Point2D还是Point3D里面都有两个虚函数。

这里有个指针p，它的类型是Point2D。

现有Point2D的虚表指针，指向Point2D的虚函数表（第一个虚函数的地址）

0x100401970,这个地址处，存放的是Point2D::print()这个虚函数，下一个地方0x100401880存放的是析构函数，

当我通过指针p去调用print，或者调用它的析构函数的时候，它的调用路径就是 先找到虚表指针->再找到虚表->再找到虚表中的项->然后根据虚表中的项（也就是找到了虚函数的地址）就可以调用了。

编译器合成的表达式就是(*p->vptr[n])(params)

分步骤看 p->vptr[n]  也就是找到在虚表中的哪一项，再解引用，再去调用函数

 这就是通过一个动态绑定虚函数调用的一个原理。

这里有几项需要解释下，

一、注意虚函数表指针没有从第一项开始指，

第一项0x100403060，这个值指向Point2D_type_info

而是指向0x100401970，也就是第一个虚函数，

要取第一项的值，下标是-1

二 、虚函数表中0x100401850,这个是什么？它也指向了一个Point2D的析构函数，怎么有两个析构函数？上面0x100401880是我们在类中声明的，下面的1850是编译器合成的，并且1850的析构函数调用了类中声明的析构函数

那么point2D的指针p指向一个point3D的对象，当通过这个指针调用虚函数的时候，它的调用路径就是 先找到虚表指针->再找到虚表->再找到虚表中的项->然后根据虚表中的项（也就是找到了虚函数的地址）就可以调用了。跟指向point2D的时候其实一样。

只不过根据所指的不同类型，调用不同的函数，这其实就是多态。

同一个类型的指针，指向基类和指向子类，调用相同名称的虚函数，它会表现出不同的行为。这就是多态。

假如Point2D中有个虚函数vfunc()，Point3D没有重写它，当然Point3D也会把它继承下来，这个时候Point2D和Point3D的虚表中都有一项指向这个虚函数。这个时候无论p指向基类还是子类，调用的都是vfunc，只不过调用路径不同。

假如Point2D中有一个非虚的函数func1()  （是一个非静态函数），通过指针p调用这个非虚函数的时候，当然就不用通过这个虚函数表了，无论p指向Point2D还是Point3D都可以调用到func1，因为继承下来了。

如果p指向一个Point3D对象，调用func1的话，要注意的是，它会有一个默认的Point3D类型的this指针把p放进来，然后编译器会进行一个强制转换，会把这个this指针转成Point2D，然后再去调用func1()函数。

假如Point3D中有一个非虚函数func2()，当p指针指向一个Point3D对象的时候，
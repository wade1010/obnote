![](https://gitee.com/hxc8/images2/raw/master/img/202407172213252.jpg)

加入我们没有声明析构函数，如果类的数据成员，或者是基类，具有析构函数的时候，编译器就会为当前的类自动合成一个析构函数。在这个合成的析构函数里面，编译器回去调用基类的析构函数，或者是数据成员的析构函数 。

从另一个角度来分析，无论是基类还是数据成员，从内存模型上来看，都是当前类的部分。

因此这个规则可以理解为，如果类对象的一部分，拥有了析构函数，那么编译器会为当前的类合成析构函数，并且在合成的析构函数里面调用这一部分的析构函数，比如基类的析构函数或者数据成员的析构函数。

![](https://gitee.com/hxc8/images2/raw/master/img/202407172213593.jpg)

![](https://gitee.com/hxc8/images2/raw/master/img/202407172213268.jpg)

Y的对象销毁的时候调用Y的析构函数，在Y的析构函数末尾有去调用了X的析构函数。

![](https://gitee.com/hxc8/images2/raw/master/img/202407172213160.jpg)

上图是反汇编代码

可以看出是在用户代码之后调用了X的析构函数，这个其实跟构造函数的合成规则是相反的。

下面讲解，当数据成员有析构函数的时候，编译器去合成析构函数的规则

![](https://gitee.com/hxc8/images2/raw/master/img/202407172213584.jpg)

Z扩充后的析构函数

~Z(){

count << "Z::~Z()" << '\n';

Y::~Y();

X::~X();

}

![](https://gitee.com/hxc8/images2/raw/master/img/202407172213996.jpg)

![](https://gitee.com/hxc8/images2/raw/master/img/202407172213337.jpg)

由低地址到高地址去构造

由高地址到低地址去析构

上图，Y依赖于X，无论数据成员还是函数成员，Y都依赖于X，那假设如果在构造Y的时候，用到了X的数据成员或者函数成员，如果不先构造X，那么用到的这些都不存在，肯定是错误的。

析构恰好相反，Y依赖X，如果先析构X，那么Y还有对X的依赖，如果在接下来析构Y的时候，需要用到X的数据成员或者函数成员，就会报错。
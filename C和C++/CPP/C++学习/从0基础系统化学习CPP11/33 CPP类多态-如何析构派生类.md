33 CPP类多态-如何析构派生类

![](https://gitee.com/hxc8/images2/raw/master/img/202407172220208.jpg)

派生类的析构函数在执行完后，会自动执行基类的析构函数，这是C++编译器强制的规定。

![](images/WEBRESOURCEbccb98ca46b70cfcea86519e90fd3e2b截图.png)

这时候基类的内存模型：AA表示的就是Person类

![](https://gitee.com/hxc8/images2/raw/master/img/202407172220396.jpg)

将基类的析构函数设置为虚函数后。

![](https://gitee.com/hxc8/images2/raw/master/img/202407172221988.jpg)

基类的虚函数表中多了一个函数，但是函数名并不是基类的析构函数~AA，而是用析构函数单词（destructor）的简写。

再查看派生类的内存模型。

![](https://gitee.com/hxc8/images2/raw/master/img/202407172221410.jpg)

之前有学习过，如果要在派生类中重定义基类的虚函数，它们的函数特征必须相同，也就是说函数名和参数列表要一致，但是基类和派生类的析构函数的函数名是不可能相同的额，不过，没关系,C++编译器会对它们做特别的处理，

析构派生类的注意事项：

1 析构派生类对象时，会自动调用基类的析构函数。与构造函数不同的是，在派生类的析构函数中，不用显示地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。

2 析构函数可以手工调用，如果对象中有堆内存，析构函数中以下代码是必要的：

delete ptr;

ptr=nullptr;

3 用基类指针指向派生类对象时，delete基类指针调用的是基类的析构函数，不是派生类的，如果希望调用派生类的析构函数，就要把基类的析构函数设置为虚函数。

4 C++编译器对虚析构函数做了特别的处理。

5 对于基类，即使它不需要析构函数，也应该提供一个虚析构函数。

6 赋值运算符函数不能继承，派生类继承的函数特征标与基类完全相同，但赋值运算符函数的特征标 随类而异，它包含了一个类型为其所属类的形参

7）友元函数不是类成员，不能继承。

![](https://gitee.com/hxc8/images2/raw/master/img/202407172221088.jpg)
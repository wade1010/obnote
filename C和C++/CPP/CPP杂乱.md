```
//数据类型 数组名[长度] = {值1,值2,.....}
//如果在初始化数据的时候，没有完全填写完，会用0来填补剩余数据
int score2[10] = {1, 2, 3, 4};
```

C++ 单例[https://blog.csdn.net/linalg/article/details/123483954](https://blog.csdn.net/linalg/article/details/123483954)

C++大部分的库都在Boost里面包装成了更好用的写法，Boost的thread比C++11的好写的多

声明函数指针

声明普通指针时，必须提供指针的类型。同样，声明函数指针时，也必须提供函数类型，函数的类型是指返回值和参数列表（函数名和形参名不是）

假设函数的原型是：

int func1(int bh,string str);

int func2(int no,string message);

int func3(int id,string info);

bool func4(int id,string info);

bool func5(int id);

则函数指针的声明是：

int  (*pfa)(int,string);

bool (*pfb)(int,string);

bool (*pfc)(int);

pfa、pfb、pfc是函数指针名，必须用括号，否则就成了返回指针的函数。

2）函数指针的赋值

函数名就是函数的地址。

函数指针的赋值：函数指针名=函数名;

3）函数指针的调用

(*函数指针名)(实参); C风格

函数指针名(实参);  C++风格

用sizeof(数组名)可以得到整个数组占用内存空间的大小（只适用于C++基本数据类型）。

用memset()函数可以把数组中全部的元素清零。（只适用于C++基本数据类型）

用memcpy()函数可以把数组中全部的元素复制到另一个相同大小的数组。（只适用于C++基本数据类型）

## **数组的地址**

a）数组在内存中占用的空间是连续的。

b）C++将数组名解释为数组第0个元素的地址。

c）数组第0个元素的地址和数组首地址的取值是相同的。

d）数组第n个元素的地址是：数组首地址+n

e）C++编译器把   数组名[下标]  **解释为**  *(数组首地址+下标)

## **数组的本质**

数组是占用连续空间的一块内存，数组名被解释为数组第0个元素的地址。C++操作这块内存有两种方法：数组解释法和指针表示法，它们是等价的。

## **数组名不一定会被解释为地址**

在多数情况下，C++将数组名解释为数组的第0个元素的地址，但是，将sizeof运算符用于数据名时，将返回整个数组占用内存空间的字节数。

可以修改指针的值，但数组名是常量，不可修改。

# **用new动态创建一维数组**

普通数组在栈上分配内存，栈很小；如果需要存放更多的元素，必须在堆上分配内存。

动态创建一维数组的语法：数据类型 *指针=new 数据类型[数组长度];

释放一维数组的语法：delete [] 指针;

注意：

l 动态创建的数组没有数组名，不能用sizeof运算符。

l 可以用数组表示法和指针表示法两种方式使用动态创建的数组。

l 必须使用delete[]来释放动态数组的内存（不能只用delete）。

l 不要用delete[]来释放不是new[]分配的内存。

l 不要用delete[]释放同一个内存块两次（否则等同于操作野指针）。

l 对空指针用delete[]是安全的（释放内存后，应该把指针置空nullptr）。

l 声明普通数组的时候，数组长度可以用变量，相当于在栈上动态创建数组，并且不需要释放。

l 如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。

为什么用delete[]释放数组的时候，不需要指定数组的大小？因为系统会自动跟踪已分配数组的内存。

**字符串在每次使用前都要初始化**，减少入坑的可能，**是每次，不是第一次**。

共同体占用内存的大小是它最大的成员占用内存的大小（内存对齐）。

```
#include <iostream>  // 包含头文件。
using namespace std; // 指定缺省的命名空间。

void func1(int **p) // 传地址，实参是指针的地址，形参是二级指针。
{
    *p = new int(3); // p是二级指针，存放指针的地址。
    cout << "func1内存的地址是：" << *p << "，内存中的值是：" << **p << endl;
}

void func2(int *&p) // 传引用，实参是指针，形参是指针的别名。
{
    p = new int(3); // p是指针的别名。
    cout << "func2内存的地址是：" << p << "，内存中的值是：" << *p << endl;
}

int main()
{
    int *p = nullptr; // 存放在子函数中动态分配内存的地址。

    func1(&p); // 传地址，实参填指针p的地址。
    // func2(p);      // 传引用，实参填指针p。

    cout << "main 内存的地址是：" << p << "，内存中的值是：" << *p << endl;

    delete p;
}
```

# **引用的形参和const **

如果引用的数据对象类型不匹配，当引用为const时，C++将创建临时变量，让引用指向临时变量。

什么时候将创建临时变量呢？

l 引用是const。

l 数据对象的类型是正确的，但不是左值。

l 数据对象的类型不正确，但可以转换为正确的类型。

结论：如果函数的实参不是左值或与const引用形参的类型不匹配，那么C++将创建正确类型的匿名变量，将实参的值传递给匿名变量，并让形参来引用该变量。

# **函数重载**

函数重载（函数多态）是指设计一系列同名函数，让它们完成相同（似）的工作。

	C++允许定义名称相同的函数，条件是它们的特征（形参的个数、数据类型和排列顺序）不同。

#1	int func(short a  ,string b);

#2	int func(int a    ,string b);

#3	int func(double a,string b);

#4	int func(int a    ,string b, int len);

#5	int func(string b , int a);

调用重载函数的时候，在代码中我们用相同的函数名，但是，后面的实参不一样，编译器根据实参与重载函数的形参进行匹配，然后决定调用具体的函数，如果匹配失败，编译器将视为错误。

在实际开发中，视需求重载各种数据类型，不要重载功能不同的函数。

注意：

l 使用重载函数时，如果数据类型不匹配，C++尝试使用类型转换与形参进行匹配，如果转换后有多个函数能匹配上，编译将报错。

l **引用可以作为函数重载的条件，但是，调用重载函数的时候，如果实参是变量，编译器将形参类型的本身和类型引用视为同一特征（就是说如果是变量，两个都能匹配上，所以报错，但是如果变量是别的类型不报错，看下面代码）。**

```
#include <iostream>
using namespace std;

void show(short a)
{
    std::cout << 1 << std::endl;
}
void show(short &a)
{
    std::cout << 2 << std::endl;
}

void test()
{
    short a = 1;
    // show(a); // 报错引用可以作为函数重载的条件，但是，调用重载函数的时候，如果实参是变量，编译器将形参类型的本身和类型引用视为同一特征。
    show(1); // 匹配到show(short a) ,怎么匹配show(short &a)呢?
    
    
    int b =1;
    show(b);//不报错，匹配的是show(short a);
}
int main()
{
    test();
    return 0;
}
```

l 如果重载函数有默认参数，调用函数时，可能导致匹配失败。

l const不能作为函数重载的特征。

返回值的数据类型不同不能作为函数重载的特征。 

# **简单使用类**

编程思想和方法的改变，披着C++外衣的C程序员。

1）类的成员函数可以直接访问该类其它的成员函数（可以递归）。

2）类的成员函数可以重载，可以使用默认参数。

3）类指针的用法与结构体指针用法相同。

4）类的成员可以是任意数据类型（类中枚举）。

5）可以为类的成员指定缺省值（C++11标准）。

6）类可以创建对象数组，就像结构体数组一样。

7）对象可以作为实参传递给函数，一般传引用。

8）可以用new动态创建对象，用delete释放对象。

9）在类的外部，一般不直接访问（读和写）对象的成员，而是用成员函数。数据隐藏是面向对象编程的思想之一。

10）对象一般不用memset()清空成员变量，可以写一个专用于清空成员变量的成员函数。

11）对类和对象用sizeof运算意义不大，一般不用。

12）用结构体描述纯粹的数据，用类描述对象。

13）在类的声明中定义的函数都将自动成为内联函数；在类的声明之外定义的函数如果使用了inline限定符，也是内联函数。

14）为了区分类的成员变量和成员函数的形参，把成员变量名加m_前缀或_后缀，如m_name或name_。

15）类的分文件编写。

1） 创建对象的时候不要在对象名后面加空的圆括号，编译器误认为是声明函数。（如果没有构造函数、构造函数没有参数、构造函数的参数都有默认参数）

**2） 在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象。**

**初始化列表与赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后再赋值。**

**如果成员是常量和引用，必须使用初始列表，因为常量和引用只能在定义的时候初始化。**

如果成员是没有默认构造函数的类，则必须使用初始化列表。

# **const修饰成员函数**

在类的成员函数后面加const关键字，表示在成员函数中保证不会修改调用对象的成员变量。

注意：

1）mutable可以突破const的限制，被mutable修饰的成员变量，将永远处于可变的状态，在const修饰的函数中，mutable成员也可以被修改。

2）非const成员函数可以调用const成员函数和非const成员函数。

3）const成员函数不能调用非const成员函数。

4）非const对象可以调用const修饰的成员函数和非const修饰的成员函数。

5）const对象只能调用const修饰的成员函数，不能调用非cosnt修饰的成员函数。

静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰的初始化（用范围解析运算符 ::）。

静态成员使用类名加范围解析运算符 :: 就可以访问，不需要创建对象。

**如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）。**

静态成员变量在程序中只有一份（生命周期与程序运行期相同，存放在静态存储区的），不论是否创建了类的对象，也不论创建了多少个类的对象。

const静态成员变量可以在定义类的时候初始化。

# **简单对象模型**

在C语言中，**数据**和**处理数据的操作（函数）**是分开的。也就是说，C语言本身没有支持**数据和函数**之间的关联性。

C++用类描述抽象数据类型（abstract data type，ADT），在类中定义了**数据**和**函数**，把**数据**和**函数**关联起来。

对象中维护了多个指针表，表中放了成员与地址的对应关系。

![](https://gitee.com/hxc8/images3/raw/master/img/202407172242911.jpg)

C++类中有两种数据成员：nonstatic、static，三种函数成员：nonstatic、static、virtual。

l 对象内存的大小包括：1）所有非静态数据成员的大小；2）由内存对齐而填补的内存大小；3）为了支持virtual成员而产生的额外负担。

l 静态成员变量属于类，不计算在对象的大小之内。

l 成员函数是分开存储的，不论对象是否存在都占用存储空间，在内存中只有一个副本，也不计算在对象大小之内。

l 用空指针可以调用没有用到this指针的非静态成员函数。

对象的地址是第一个非静态成员变量的地址，如果类中没有非静态成员变量，编译器会隐含的增加一个1字节的占位成员。

![](https://gitee.com/hxc8/images3/raw/master/img/202407172242835.jpg)

以下运算符只能通过成员函数进行重载：

=                赋值运算符

 ()                函数调用运算符

 []                下标运算符

 ->               通过指针访问类成员的运算符

# **重载下标运算符**

如果对象中有数组，重载下标运算符[]，操作对象中的数组将像操作普通数组一样方便。

下标运算符必须以成员函数的形式进行重载。

下标运算符重载函数的语法：

返回值类型 &perator[](参数);

或者：

const 返回值类型 &operator[](参数) const;

使用第一种声明方式，[]不仅可以访问数组元素，还可以修改数组元素。

使用第二种声明方式，[]只能访问而不能修改数组元素。

在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应const对象，因为通过const 对象只能调用const成员函数，如果不提供第二种形式，那么将无法访问const对象的任何数组元素。

在重载函数中，可以对下标做合法性检查，防止数组越界。

# **重载括号运算符**

括号运算符()也可以重载，对象名可以当成函数来使用（函数对象、仿函数）。

括号运算符重载函数的语法：

返回值类型 operator()(参数列表);

注意：

l 括号运算符必须以成员函数的形式进行重载。

l 括号运算符重载函数具备普通函数全部的特征。

l 如果函数对象与全局函数同名，按作用域规则选择调用的函数。

函数对象的用途：

1）表面像函数，部分场景中可以代替函数，在STL中得到广泛的应用；

2）函数对象本质是类，可以用成员变量存放更多的信息；

3）函数对象有自己的数据类型；

4）可以提供继承体系。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
           
void show(string str)    // 向超女表白的函数。
{
	cout << "普通函数：" << str << endl;
}
          
class CGirl      // 超女类。
{
public:
	void operator()(string str)    // 向超女表白的函数。
	{
		cout << "重载函数：" << str << endl;
	}
};
           
int main()
{
  CGirl show;
	::show("我是一只傻傻鸟。");
	show("我是一只傻傻鸟。");
}
```

C++ 规定，重载++或--时，如果重载函数有一个int形参，编译器处理后置表达式时将调用这个重载函数。

成员函数版：CGirl &operator++();             // ++前置

成员函数版：CGirl operator++(int);            // 后置++

非成员函数版：CGirl &operator++(CGirl &);   // ++前置

非成员函数版：CGirl operator++(CGirl &,int);  // 后置++

# **转换函数**

构造函数只用于从某种类型到类类型的转换，如果要进行相反的转换，可以使用特殊的运算符函数-转换函数。

语法：operator 数据类型();

**注意：转换函数必须是类的成员函数；不能指定返回值类型；不能有参数。**

如果隐式转换存在二义性，编译器将报错。

在C++98中，关键字explicit不能用于转换函数，但C++11消除了这种限制，可以将转换函数声明为显式的。

还有一种方法是：用一个功能相同的普通成员函数代替转换函数，普通成员函数只有被调用时才会执行。

int ii=girl.to_int();

警告：应谨慎的使用隐式转换函数。通常，最好选择仅在被显式地调用时才会执行的成员函数。

**使用 using 关键字可以改变基类成员在派生类中的访问权限。**

注意：using只能改变基类中public和protected成员的访问权限，不能改变private成员的访问权限，因为基类中的private成员在派生类中是不可见的，根本不能使用。

示例：

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class A  {        // 基类
public:
    int m_a=10;
protected:
    int m_b=20;
private:
    int m_c = 30;
};

class B :public A        // 派生类
{
public:
    using A::m_b;         // 把m_b的权限修改为公有的。
private:
    using A::m_a;         // 把m_a的权限修改为私有的。
};

int main()
{
    B b;   
    // b.m_a = 11;
    b.m_b = 21;
    //b.m_c = 21;
}
```

8）对派生类对象用memset()会清空基类私有成员。

9）用指针可以访问到基类中的私有成员（内存对齐）

```
class A {        // 基类
public:
    int m_a = 10;
protected:
    int m_b = 20;
private:
    int m_c = 30;
};
class B :public A        // 派生类
{
};
```

B *p=new B;

**((int**)p + 2) = 31;        // 把基类私有成员m_c的值修改成31。

delete p;

# **继承的特殊关系**

派生类和基类之间有一些特殊关系。

1）如果继承方式是公有的，派生类对象可以使用基类成员。

2）可以把派生类对象赋值给基类对象（包括私有成员），但是，会舍弃非基类的成员。

3）基类指针可以在不进行显式转换的情况下指向派生类对象。

4）基类引用可以在不进行显式转换的情况下引用派生类对象。

注意：

1）基类指针或引用只能调用基类的方法，不能调用派生类的方法。如果在基类的成员函数前加virtual 关键字，把它声明为虚函数，基类指针就可以调用派生类中同名的成员函数，通过派生类中同名的成员函数，就可以访问派生对象的成员变量。

2）可以用派生类构造基类。

3）如果函数的形参是基类，实参可以用派生类。

4）C++要求指针和引用类型与赋给的类型匹配，这一规则对继承来说是例外。但是，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针（没有价值，没有讨论的必要）。

# **多态的基本概念**

基类指针只能调用基类的成员函数，不能调用派生类的成员函数。

如果在基类的成员函数前加virtual 关键字，把它声明为虚函数，基类指针就可以调用派生类中同名的成员函数，通过派生类中同名的成员函数，就可以访问派生对象的成员变量。

有了虚函数，基类指针指向基类对象时就使用基类的成员函数和数据，指向派生类对象时就使用派生类的成员函数和数据，基类指针表现出了多种形式，这种现象称为多态。

基类引用也可以使用多态。

注意：

1）只需要在基类的函数声明中加上virtual关键字，函数定义时不能加。

2）在派生类中重定义虚函数时，函数特征要相同。

3）当在基类中定义了虚函数时，如果派生类没有重定义该函数，那么将使用基类的虚函数。

4）在派生类中重定义了虚函数的情况下，如果想使用基类的虚函数，可以加类名和域解析符。

5）如果要在派生类中重新定义基类的函数，则将它设置为虚函数；否则，不要设置为虚函数，有两方面的好处：首先效率更高；其次，指出不要重新定义该函数。

C++中的多态分为两种：静态多态与动态多态。

静态多态：也成为编译时的多态；在编译时期就已经确定要执行了的函数地址了；主要有函数重载和函数模板。

动态多态：即动态绑定，在运行时才去确定对象类型和正确选择需要调用的函数，一般用于解决基类指针或引用派生类对象调用类中重写的方法（函数）时出现的问题。

//动态多态满足条件

//1 有继承关系

//2 子类要重写（不是重载）父类的虚函数

对于基类，即使它不需要析构函数，也应该提供一个空虚析构函数。

赋值运算符函数不能继承，派生类继承的函数的特征标与基类完全相同，但赋值运算符函数的特征标随类而异，它包含了一个类型为其所属类的形参。

友元函数不是类成员，不能继承。

![](https://gitee.com/hxc8/images3/raw/master/img/202407172242348.jpg)

![](https://gitee.com/hxc8/images3/raw/master/img/202407172242204.jpg)

# **函数模板的注意事项**

1）可以为类的成员函数创建模板，但不能是虚函数和析构函数。

2）使用函数模板时，必须明确数据类型，确保实参与函数模板能匹配上。

```
    // int a = 10;
    // int b = 10;
    // mySwap(a, b);
```

3）使用函数模板时，推导的数据类型必须适应函数模板中的代码。

```
    // int a = 10;
    // char b = 10;
    // mySwap(a, b);//错误
```

4）使用函数模板时，如果是自动类型推导，不会发生隐式类型转换，如果显式指定了函数模板的数据类型，可以发生隐式类型转换。

```
int c = 10;
char d = 20;
int f = Add<int>(c, d); // 指定类型,会发生隐式类型转换
```

5）函数模板支持多个通用数据类型的参数。

6）函数模板支持重载，可以有非通用数据类型的参数。

对于给定的函数名，可以有普通函数、函数模板和具体化的函数模板，以及它们的重载版本。

编译器使用各种函数的规则：

1）具体化优先于常规模板，普通函数优先于具体化和常规模板。

2）如果希望使用函数模板，可以用空模板参数强制使用函数模板。

3）如果函数模板能产生更好的匹配，将优先于普通函数。

# **函数模板分文件编写**

函数模板只是函数的描述，没有实体，创建函数模板的代码放在头文件中。

函数模板的具体化有实体，编译的原理和普通函数一样，所以，声明放在头文件中，定义放在源文件中。

decltype的结果要么和表达式的类型相同，要么就是表达式的类型的引用。

# **模板类的基本概念**

注意：

1）在创建对象的时候，必须指明具体的数据类型。

2）使用类模板时，数据类型必须适应类模板中的代码。

3）类模板可以为通用数据类型指定缺省的数据类型（C++11标准的函数模板也可以）。

4）模板类的成员函数可以在类外实现。

5）可以用new创建模板类对象。

6）在程序中，模板类的成员函数使用了才会创建。

# **156、模板类与继承**

1）模板类继承普通类（常见）。主要是把基类的构造函数安排好。

2）普通类继承模板类的实例化版本。

3）普通类继承模板类。(常见)

4）模板类继承模板类。

5）模板类继承模板参数给出的基类（不能是模板类）。

上述5示例如下：

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class AA {
public:
    AA()         { cout << "调用了AA的构造函数AA()。\n"; }
    AA(int a) { cout << "调用了AA的构造函数AA(int a)。\n"; }
};

class BB {
public:
    BB()         { cout << "调用了BB的构造函数BB()。\n"; }
    BB(int a) { cout << "调用了BB的构造函数BB(int a)。\n"; }
};

class CC {
public:
    CC()         { cout << "调用了CC的构造函数CC()。\n"; }
    CC(int a) { cout << "调用了CC的构造函数CC(int a)。\n"; }
};

template<class T>
class DD {
public:
    DD()         { cout << "调用了DD的构造函数DD()。\n"; }
    DD(int a) { cout << "调用了DD的构造函数DD(int a)。\n"; }
};

template<class T>
class EE : public T {          // 模板类继承模板参数给出的基类。
public:
    EE() :T()           { cout << "调用了EE的构造函数EE()。\n"; }
    EE(int a) :T(a) { cout << "调用了EE的构造函数EE(int a)。\n"; }
};

int main()
{
    EE<AA> ea1;                 // AA作为基类。
    EE<BB> eb1;                 // BB作为基类。
    EE<CC> ec1;                 // CC作为基类。
    EE<DD<int>> ed1;      // EE<int>作为基类。
    // EE<DD> ed1;                // DD作为基类，错误。
}
```

将模板类用作参数

```
template<template<class, int >class T1, class T2, int len>
class LinearList{
    ......
};
```

表示T1不是一个普通的参数，而是模板，意思是这个参数要填模板名，不要填int、string等普通类型。填什么样的模板名呢？填有两个参数的类模板名。必须是两个参数的类模板名。

且要求类模板的第一个参数是通用类型，第二个是非通用类型。

## 编译和链接**更多细节**

1）分开编译的好处：每次只编译修改过的源文件，然后再链接，效率最高。

2）编译单个*.cpp文件的时候，必须要让编译器知道名称的存在，否则会出现找不到标识符的错误。（直接和间接包含头文件都可以）

3）编译单个*.cpp文件的时候，编译器只需要知道名称的存在，**不会把它们的定义一起编译**。

4）如果函数和类的定义不存在，编译不会报错，但链接会出现无法解析的外部命令。

5）链接的时候，变量、函数和类的定义只能有一个，否则会出现重定义的错误。（如果把变量、函数和类的定义放在*.h文件中，*.h会被多次包含，链接前可能存在多个副本；如果放在*.cpp文件中，*.cpp文件不会被包含，只会被编译一次，链接前只存在一个版本）

6）把变量、函数和类的定义放在*.h中是不规范的做法，如果*.h被多个*.cpp包含，会出现重定义。

7）用#include包含*.cpp也是不规范的做法，原理同上。

8）尽可能不使用全局变量，如果一定要用，要在*.h文件中声明（需要加extern关键字），在*.cpp文件中定义。

9）全局的const常量在头文件中定义（const常量仅在单个文件内有效）。

10）*.h文件重复包含的处理方法只对单个的*.cpp文件有效，不是整个项目。

11）函数模板和类模板的声明和定义可以分开书写，但它们的定义并不是真实的定义，只能放在*.h文件中；函数模板和类模板的具体化版本的代码是真实的定义，所以放在*.cpp文件中。

一、static_cast

static_cast是最常用的C++风格的强制类型转换，主要是为了执行那些较为合理的强制类型转换，使用格式如下：

static_cast<目标类型>(表达式);

1）用于基本内置数据类型之间的转换

2）用于指针之间的转换

C风格：可用于各种类型指针之间的转换。

static_cast：各种类型指针之间的不允许转换，必须借助void*类型作为中间介质。

3）不能转换掉expression的const或volitale属性

二、const_cast

static_cast不能丢掉指针（引用）的const和volitale属性，const_cast可以。

三、reinterpret_cast

static_cast不能用于转换不同类型的指针（引用）（不考虑有继承关系的情况），reinterpret_cast可以。

reinterpret_cast的意思是重新解释，能够将一种对象类型转换为另一种，不管它们是否有关系。

语法：reinterpret_cast<目标类型>(表达式);

<目标类型>和(表达式)中必须有一个是指针（引用）类型。

reinterpret_cast不能丢掉(表达式)的const或volitale属性。

应用场景：

1）reinterpret_cast的第一种用途是改变指针（引用）的类型。

2）reinterpret_cast的第二种用途是将指针（引用）转换成整型变量。整型与指针占用的字节数必须一致，否则会出现警告，转换可能损失精度。

3）reinterpret_cast的第三种用途是将一个整型变量转换成指针（引用）。

```
#include <iostream>
using namespace std;

void func(void* ptr) {  
    long long ii = reinterpret_cast<long long>(ptr);
    cout << "ii=" << ii << endl;
}

int main(int argc, char* argv[])
{
    long long ii = 10;

    func(reinterpret_cast<void *>(ii));
}
```

dynamic_cast运算符用指向基类的指针来生成派生类的指针，它不能回答“指针指向的是什么类的对象”的问题，但能回答“是否可以安全的将对象的地址赋给特定类的指针”的问题。

语法：派生类指针 = dynamic_cast<派生类类型 *>(基类指针);

如果转换成功，dynamic_cast返回对象的地址，如果失败，返回nullptr。

注意：

1）dynamic_cast只适用于包含虚函数的类。

2）dynamic_cast可以将派生类指针转换为基类指针，这种画蛇添足的做法没有意义。

3）dynamic_cast可以用于引用，但是，没有与空指针对应的引用值，如果转换请求不正确，会出现bad_cast异常。

**迭代器失效的问题**

resize()、reserve()、assign()、push_back()、pop_back()、insert()、erase()等函数会引起vector容器的动态数组发生变化，可能导致vector迭代器失效。

map

注意：

1）[ ]运算符：如果指定键不存在，会向容器中添加新的键值对；如果指定键存在，则读取或修改容器中指定键的值。

2）at()成员函数：如果指定键不存在，不会向容器中添加新的键值对，而是直接抛出out_of_range 异常。

使用方法

智能指针重载了**和->操作符，可以像使用指针一样使用unique_ptr。**

**不支持普通的拷贝和赋值。**

AA p = new AA("西施");

unique_ptr<AA> pu2 = p;              // 错误，不能把普通指针直接赋给智能指针。

unique_ptr<AA> pu3 = new AA("西施"); // 错误，不能把普通指针直接赋给智能指针。

unique_ptr<AA> pu2 = pu1;           // 错误，不能用其它unique_ptr拷贝构造。

unique_ptr<AA> pu3;

pu3 = pu1;                            // 错误，不能用=对unique_ptr进行赋值。

不要用同一个裸指针初始化多个unique_ptr对象。

get()方法返回裸指针。

不要用unique_ptr管理不是new分配的内存。

3）用于函数的参数

传引用（不能传值，因为unique_ptr没有拷贝构造函数）。

裸指针。

4）不支持指针的运算（+、-、++、--）

```
 unique_ptr<AA> up(new AA("hello"));
```

更多技巧

1）将一个unique_ptr赋给另一个时，如果源unique_ptr是一个临时右值，编译器允许这样做；如果源unique_ptr将存在一段时间，编译器禁止这样做。一般用于函数的返回值。

unique_ptr<AA> p0;

p0 = unique_ptr<AA>(new AA ("西瓜"));

2）用nullptr给unique_ptr赋值将释放对象，空的unique_ptr==nullptr。

3）release()释放对原始指针的控制权，将unique_ptr置为空，返回裸指针。（可用于把unique_ptr传递给子函数，子函数将负责释放对象）

4）std::move()可以转移对原始指针的控制权。（可用于把unique_ptr传递给子函数，子函数形参也是unique_ptr）

5）reset()释放对象。

void reset(T * _ptr= (T *) nullptr);

pp.reset();        // 释放pp对象指向的资源对象。

pp.reset(nullptr);  // 释放pp对象指向的资源对象

pp.reset(new AA("bbb"));  // 释放pp指向的资源对象，同时指向新的对象。

6）swap()交换两个unique_ptr的控制权。

void swap(unique_ptr<T> &_Right);

7）unique_ptr也可象普通指针那样，当指向一个类继承体系的基类对象时，也具有多态性质，如同使用裸指针管理基类对象和派生类对象那样。

8）unique_ptr不是绝对安全，如果程序中调用exit()退出，全局的unique_ptr可以自动释放，但局部的unique_ptr无法释放。

9）unique_ptr提供了支持数组的具体化版本。

数组版本的unique_ptr，重载了操作符[]，操作符[]返回的是引用，可以作为左值使用。

// unique_ptr<int[]> parr1(new int[3]);          // 不指定初始值。

unique_ptr<int[]> parr1(new int[3]{ 33,22,11 });  // 指定初始值。

cout << "parr1[0]=" << parr1[0] << endl;

cout << "parr1[1]=" << parr1[1] << endl;

cout << "parr1[2]=" << parr1[2] << endl;

shared_ptr的线程安全性：

shared_ptr的引用计数本身是线程安全（引用计数是原子操作）。

多个线程同时读同一个shared_ptr对象是线程安全的。

如果是多个线程对同一个shared_ptr对象进行读和写，则需要加锁。

多线程读写shared_ptr所指向的同一个对象，不管是相同的shared_ptr对象，还是不同的shared_ptr对象，也需要加锁保护。

11）如果unique_ptr能解决问题，就不要用shared_ptr。unique_ptr的效率更高，占用的资源更少。

//catch (...)  // 不管什么异常，都在这里处理。

//{

//    cout << "捕获到异常，具体没管是什么异常。\n";

//}

**如果程序中的异常没有被捕获，程序将异常中止。**

## **final关键字**

final关键字用于限制某个类不能被继承，或者某个虚函数不能被重写。

final关键字放在类名或虚函数名的后面。

## **override关键字**

在派生类中，把override放在成员函数的后面，表示重写基类的虚函数，**提高代码的可读性。**

在派生类中，如果某成员函数不是重写基类的虚函数，随意的加上override关键字，编译器会报错。

C++11 标准中，建议将const和constexpr的功能区分开，表达“只读”语义的场景用const，表达“常量”语义的场景用constexpr。

## **左值、右值**

在C++中，所有的值不是左值，就是右值。左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束后就不再存在的临时对象。有名字的对象都是左值，右值没有名字。

还有一个可以区分左值和右值的便捷方法：**看能不能对表达式取地址，如果能，则为左值，否则为右值**。

C++11扩展了右值的概念，将右值分为了纯右值和将亡值。

l 纯右值：a）非引用返回的临时变量；b）运算表达式产生的结果；c）字面常量（C风格字符串除外，它是地址）。

l 将亡值：与右值引用相关的表达式，例如：将要被移动的对象、T&&函数返回的值、std::move()的返回值、转换成T&&的类型的转换函数的返回值。

不懂纯右值和将亡值的区别其实没关系，统一看作右值即可，不影响使用。

**引入右值引用的主要目的是实现移动语义。**

左值引用只能绑定（关联、指向）左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。

但是，常量左值引用却是个奇葩，它可以算是一个万能的引用类型，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改。

int a = 1;

const int& ra = a;   // a是非常量左值。

const int b = 1;

const int& rb = b;  // b是常量左值。

const int& rc = 1;   // 1是右值。

std::move()方法来将左值转义为右值

如果没有提供移动构造/赋值函数，只提供了拷贝构造/赋值函数，编译器找不到移动构造/赋值函数就去寻找拷贝构造/赋值函数。

3）C++11中的所有容器都实现了移动语义，避免对含有资源的对象发生无谓的拷贝。

4）移动语义对于拥有资源（如内存、文件句柄）的对象有效，如果是基本类型，使用移动语义没有意义。

完美转发

在函数模板中，可以将参数“完美”的转发给其它函数。所谓完美，即不仅能准确的转发参数的值，还能保证被转发参数的左、右值属性不变。

C++11标准引入了右值引用和移动语义，所以，能否实现完美转发，决定了该参数在传递过程使用的是拷贝语义还是移动语义。

为了支持完美转发，C++11提供了以下方案：

1）如果模板中（包括类模板和函数模板）函数的参数书写成为T&& 参数名，那么，函数既可以接受左值引用，又可以接受右值引用。

2）提供了模板函数std::forward<T>(参数) ，用于转发参数，如果 参数是一个右值，转发之后仍是右值引用；如果参数是一个左值，转发之后仍是左值引用。

```
可变函数和参数
写一个函数，函数的参数是函数对象及参数，功能和thread类的构造函数相同。
示例：
#include <iostream>
#include <thread>
#include <functional>        
using namespace std;

void show0() {  // 普通函数。
	cout << "亲爱的，我是一只傻傻鸟。\n";
}

void show1(const string& message) {  // 普通函数。
	cout << "亲爱的，" << message << endl;
}

struct CC	// 类中有普通成员函数。
{
	void show2(int bh, const string& message) {
		cout << "亲爱的" << bh << "号，" << message << endl;
	}
};

template<typename Fn, typename...Args>
auto show(Fn&& fn, Args&&...args) -> decltype(bind(forward<Fn>(fn), forward<Args>(args)...))
{
	cout << "表白前的准备工作......\n";

	auto f = bind(forward<Fn>(fn), forward<Args>(args)...);
	f();

	cout << "表白完成。\n";
	return f;
}

int main()
{
	show(show0);
	show(show1,"我是一只傻傻鸟。");
	CC cc;
	auto f = show(&CC::show2,&cc, 3,"我是一只傻傻鸟。");
	f();
	
	//thread t1(show0);
	//thread t2(show1,"我是一只傻傻鸟。");
	//CC cc;
	//thread t3(&CC::show2,&cc, 3,"我是一只傻傻鸟。");
	//t1.join();
	//t2.join();
	//t3.join();
}
```
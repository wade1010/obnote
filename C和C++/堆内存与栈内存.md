1. 栈内存

栈内存是为线程留出的临时空间，每个线程都有一个固定大小的栈空间，而且栈空间存储的数据只能由当前线程访问，所以它是线程安全的。

栈空间的分配和回收是由系统来做的，我们不需要手动控制。

当一个函数调用时，系统就会为该函数的调用分配栈空间，当函数返回后，系统就会自动回收这块空间，同理，下次其它函数调用和返回，系统还是会自动分配和回收空间。

那它是怎么分配和回收的呢？

栈空间的大小是固定的，它有一个水位线标识栈空间的分配状态，水位线里面的表示已经分配，然后这个水位线会根据函数调用和返回的情况自动调整。

这里可以看到，栈空间的分配和回收非常简单，只需要调整水位线位置就可以了，没有任何多余操作。

1. 堆内存

我们平时在 C 语言和 C++ 中使用 malloc 和 new 分配的内存就是堆内存，堆内存的一大特点就是大小不固定，可以动态扩容，空间由程序员动态分配，更加灵活。

然而，既然有优点也必然伴随着缺点。

第一个缺点就是它容易产生内存泄露，malloc 出来的没有 free，new 出来的如果没有 delete，都会产生内存泄露，真正项目内存泄露产生的情况肯定比这个复杂得多。

第二个缺点，容易产生内存碎片，在分配和回收时需要对很多内存碎片进行整理，效率较低

所以才会有很多自定义的[内存分配](https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D&spm=1001.2101.3001.7020)器，但它肯定还是没有栈空间分配回收速度快。

第三个缺点，线程不安全，它不像栈内存是线程独立的，堆内存可以被一个进程内所有的线程访问，多线程操作就容易产生问题，很多奇奇怪怪的操作就是这么引起的。

1. 只能在堆上分配内存的类

方法：将析构函数设置为私有

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

示例

```
class A {
public:
    A() {}
 
    void destory() { delete this; }
 
private:
    ~A(){}
};
```

4. 只能在栈上分配内存的类

方法：将 new 和 delete 重载为私有

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

示例

```
class A
{
private:
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的
    void operator delete(void* ptr){} // 重载了new就需要重载delete
public:
    A(){}
    ~A(){}
};
```
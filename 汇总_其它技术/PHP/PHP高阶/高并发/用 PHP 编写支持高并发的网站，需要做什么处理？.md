著作权归作者所有。

商业转载请联系作者获得授权，非商业转载请注明出处。

作者：甘醇

链接：https://www.zhihu.com/question/20049768/answer/21635940

来源：知乎



一般来说,解决WEB高并发的有效手段都是采用可线性扩展的多层分布式架构，

我生产项目的架构是这样的，就在这里抛砖引玉一下。

1. Webserver (Nginx) ：这一层是可以轻松分布式部署的，结合智能DNS解析可以简易地防止单点故障、实现区域访问加速，结合LVS很容易实现负载均衡。这一层主要是负责处理静态请求和转发PHP请求至第二层的PHP处理节点，至于静态资源地址(http://misc.xxxx.com)可以单独拿出来部署，或者直接使用商用的云存储服务（国内七牛不错，国外有Amazon S3）

1. PHP处理节点：一个节点其实就是一个监听特定端口的系统进程，webserver的请求通过负载均衡器（我用的AWS的loadbalancer)进行分发，很好实现分布式和负载均衡。我现在用的还是php自带的php-fpm,其实facebook出的hhvm性能非常强悍，但是还不能100%通过我项目的单元测试，等hhvm成熟过后可以平滑替换

1. 高速缓存：用的memcached，这一层的作用主要是减轻数据库IO和加快热数据访问，缓存策略与程序耦合度较高，不赘述，但简单地说有两种方式，一种是在程序的全局层面加一个缓存处理，这种方法代码耦合度低，但是有效命中率不高，有些项目不一定适应，另一种是在具体的数据存取处加缓存处理，这种办法程序耦合度较高，但是缓存命中率非常高，几乎没有无效缓存存在，我用的是这种。

1. 数据库 ：我现在的项目数据规模不大，暂时只用了单台数据库，但是程序逻辑上已做好了数据库线性扩展的准备。其实数据库层的扩展是老生常谈了，常用手段是分库分表，这一块需要在前期的代码就打下基础，另外更平滑地手段是使用中间件，比如360的Atlas，阿里巴巴的cobar，淘宝的TDDL，中间件可以在不大范围变更代码的情况下扩展，但是具体的使用场景还是有限的，具体项目还需单独考察。

1. 其他：根据不同的项目，架构还可以选择性地使用队列，我现在用的beantalkd，Redis也是一个很好的选择。队列常用的使用环境是邮件发送和站内消息推送上面，但是在某些场景下也可以作为核心数据库的缓冲，对应对大并发或者突发性流量也是不错的选择









一般使用LVS+PHP集群（1000台），就算日均80亿次请求，每秒有10万并发，那分到每台机器的请求只有100个。只要你的PHP程序不是太差，100QPS总没问题吧？



而真正的瓶颈在于数据库和存储系统，数据的一致性，可扩展性，可用性很难保证。所以需要根据具体的业务场景再做横向和纵向的分库分表。



再辅以memcache集群缓存，key-value高性能存储，异步队列任务系统，整个架构就可以建立起来。



还有一类是真正的高并发，比如WebIM，一台机器要承受数十万的TCP客户端连接，进行大规模的实时通信。这种的可以用PHP的异步高并发扩展swoole 。链接：Swoole: PHP的异步、并行、分布式扩展框架、







一层层剥开来讲，有以下部位需要注意。

1.资源。能静态实现的就静态实现，静态资源也要尽量使用分布式存储，例如云存储。

2.效率。PHP代码里，尽量注意内存的使用，单个脚本的运行效率要Ok.

3.缓存。使用memcache来实现非持久存储，使用no-sql来实现持久存储。

4.server。使用nginx+fpm或者nginx+apache，来实现动静态分离访问。

5.mysql。作为最终的存储库以及一些不可避免的实时调用库，做主从处理，Master+多Slave，多个只读副本来实现实时的调用库。

6.负载。建议架设一层负载均衡，来实现web server的轮询。例如云平台中的LBS。











php是一个语言工具，由php来把apache/nginx/memcache/redis/mysql/httpds等工具组合到一起，根据具体的业务需求，选取不同的系统架构模型；高并发其实考验的是系统的架构

1. 数据的读写层

高并发更多考验的是数据的读写，最终考验的是根据具体的业务需求进行系统的架构；哪些数据要满足实时读写，哪些数据可以异步读写等要考虑好；数据的读写模型分析清楚后就要设计数据的存储方案，mysql擅长的是关系数据和数据统计，但是并发访问是瓶颈；memcache擅长的是数据缓存，但kv的数据结构有限;redis作为内存数据库但内存空间毕竟没有硬盘空间大；

各有优缺点，那么就要根据自己的业务来综合或者选取用这些工具

2. 静态/动态访问

有条件的就使用cdn,没条件的至少弄一个静态访问层，至于使用apache还是nginx或者其它的，自己在虚拟机上都安装一遍，做一个压力测试对比一下

非静态访问转发到动态访问层

3. 逻辑处理即php

到php了，php承接动态访问的输入，进行逻辑运算，最后到数据层去进行读写；

别做太傻的事就可以了，比如无谓的foreach循环，复制等操作；再比如，对于实时访问，对10个数据进行排序，就不要再用mysql 的select order by 了，直接用php的函数来排序就好了。





cdn+缓存+静态化




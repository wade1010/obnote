5

![](https://gitee.com/hxc8/images8/raw/master/img/202407191107490.jpg)





比方说我们打开的一个文件以及创建了一个soccer的连接，这些都属于IO句柄，然后这这些句柄也会在子进程中被复制一份，并且就是跟原来的那个连接是一样的，就说比方说我在父进程中打开了一个文件，用fopen就是打开一个文件，得到一个那个fp描述符，那么在子进程中同样会拥有这个句柄，并且可以对同一个文件进行读写操作，那么这样的情况下就在多进程中这样同时对一个文件。进行写操作的话，就可能造成文件内容乱掉，这个时候我们就需要文件所这样的东西来保证那个对文件读写的互斥。今天要讲这个是因为我们在后面的就是process那章中讲到进程通讯的时候会涉及到这一点，这个到时候就是讲到第三章的时候我在具体的跟大家细讲。





进程间通信方式-管道

![](https://gitee.com/hxc8/images8/raw/master/img/202407191107289.jpg)

第一种方式比较常见的就是管道。那么管道呢其实它是一个比较特殊的描述符。我们在父进程中创建一个管道的时候，这个管道是会创建一组。就是两个描述符，一个描述符用来读 一个描述符用来写，这两个描述符中一种比较特殊的方式连接在一起的。那么当父进程创建了一个管道之后。他所制造出来的，以这个子进程呢，也会拥有同样的两个相同的描述。那么当父进程通过往描述符当中写内容的时候，子进程就可以通过读描述符来读到管道中的内容。那么这样就实现两个进程间的通信，也就是说相当于我跟你一人两个人手中拿了一个管子，我从管子这头投递一个东西过去给你。你从管子的另外一头收到，管子是单向的，我给你的这根管子你不能给我数据，你要通过另外一根管来。这样的话就是比较形象一点的一个管道，就是这也是为什么我们把它翻译为这个东西，就是，因为它是一个单向的通讯，需要同时拥有两个通路。



那么管道就是说一组两个比较特殊的描述符，它必须在fork函数之前创建，就是说我们必须在子进程被创建出来之前就要创建一个管道，这样才能保证说两个进程都拥有这个管道的实例。我们这样才能让两个进程之间可以通过这个管道来通讯。



需要注意的就是说其中的任意一端，比如子进程，它是可以主动关闭这个管道的。就相当于说如果我这边不想跟你继续通讯了，我把这个管道主动关掉，那么另外一边，我父进程一直在试图读这个管道中的数据的，我发现管道已经关了，那么我这边读的操作就会返回0，我就知道对端已经把这个通路给关闭了，他不会再继续发数据过来了，那么父进程这边再去做主动的操作，就是把他这边的管道里关掉，这样完成一个完整的管道的关闭的过程

 



进程间通信方式-消息队列

![](https://gitee.com/hxc8/images8/raw/master/img/202407191107240.jpg)



假设存在两个子进程的话，消息队列就是独立于两个进程之外的。他跟共享内存很像，是一个独立于进程之外的这么一片特殊的空间。我们可以通过指定一个k值来创建一个消息队列，那么只要拥有相同的key，我们就可以访同一个消息队列，这样保证了多个进程之间，他们会连接到同一个消息队列，才能够实现,基于这个消息队列的通讯，那么这个key是很重要的。

另外一点就是说我们在消息队列中传递的数据包，就是它所传递的数据是一个一个的数据块，并不是像管道那样是一个流式的通讯，就是类似TCP这样的，消息队列，可能更像UDP这样的。发给你一个数据包，发发发，发完之后，另外一个进程就是去读，他读的也是一个一个一个的数据块，那么在管道中传的这个数据包的大小是有限的，这个是一般是操作系统。本身有一个设置的。默认的话一般是我记得是65535。哪个int的最大值，然后这个只是可以去修改它的。

那么当一个消息队列被创建之后，比方说我子进程一创建了这个调用一个接口key去创建了这个消息队列，那么这个消息队列就会一直存在系统内存当中，他不会说子进程关闭了的话，那么这个消息队列仍然会他其中的消息还会被保留，一直到有任何一个进程主动的关闭了这个消息队列，那么它其中的消息就会被清空，这样一个好处就是说，比方说我们可能就是在线上的服务器中会存在一些问题，比如说我一个服务进程。正在处理来自客户端的请求的时候，突然出了一些问题，这个进程挂了。那么可能当前正在处理的这个请求或者说他还没有来得及去处理的请求就丢了。你后面服务再起来可能就找不到这些请求了。那么消息队列就可以做到说他可以就是说你这个进程如果没有了这些消息，仍然可以保留在这个队列当中，你下一次再把这个进程拉起来，再访问到这个消息队列，能继续获取数据。就是进程间的消息队列的通讯方式。





IO多路复用

![](https://gitee.com/hxc8/images8/raw/master/img/202407191107796.jpg)

 我们一般会讲叫做同步io和异步lO。但实际上来说我们,就是说讲到异步IO的时候，更多的都是在说，就是epoll或者那个kqueue，但是这些函数的实质，他们实质上并不是真正的异步IO，他们实际上是lO的复用，就是他们他们其实本身还是阻塞的，就说我调用这个epoll函数的时候，他是会阻塞在那里的，他阻塞在干什么呢？他是不停的监听自己名下所管理的那些描述符，比如说上图中是有五个描述符注册在了这个epoll函数里面，那么他就会不停地去监听这五个描述。那就是说当这些socket描述符当中有任意的一个或者几个描述符有了事件响应，比如说某一个描述符，里面有来自客户端的数据了。某一个描述符可以开始准备往客户端写数据了，或者某一个描述符被关闭了诸如此类的这些事件的时候，一旦这些事件发生了，epoll函数才会响应，并且返回这些有事件发生的socket的集合，然后让客户端再去一个一个去处理。所以你会发现他并不是真正的就是异步的，就是说我这边丢一个事情过去，然后整个整个事情就一直在底层去等待，他实际上还是阻塞在那里。这个概念一定要清楚。

但另外一点就是说epoll他的优点,在于它能同时处理大量的socket连接，这个大量就是非常非常大，比如c10k的问题或c1000k的问题，这些问题都是要基于这种多路复用来实现的，因为只有这样我们才能够同时去处理万级以上的这些socket的连接，如果是阻塞的话，开进程。开线程去一个一个去处理的。就是他的优点就是说允许我们在同一个进程之内同时处理这么多的描述符。所以就是说这个就是我们目前的网络编大多数的高性能网络编程服务器的本质，包括swoole扩展，swoole扩展的网络也是基于epoll函数来实现的，





Eventloop

![](https://gitee.com/hxc8/images8/raw/master/img/202407191107534.jpg)

Event loop就是事件循环。实际上就是swoole为大家提供了一个epoll上层的封装，并且提供了一个线程。当我们通过那个swoole event的这一些列的函数去。发起创建这么一个事件循环的时候，swoole会在底层启动一个reactor线程。他们这个线程中会实际的运行一个epoll实例，我们需要去注册描述符到这个epoll实例当中，并未他设置read和write的监听。



我们从从最上面add开始来讲，就是说这个这个函数的作用就是说我们将一个socket描述符加入到swoole的监听当中，并且可以为他设置，比如说读就是读事件的回调和写事件的回到。当这个我们传入进去的socket真正的发生了事件。就是比方说有数据传过来了，那么这个回调就会被响应，那么我们就可以在这个回调中去处理一些消息。



不能用于FPM环境。在FPM中，当一个请求结束的时候，这个进程可能就会被关掉。那么就会引起就是说我们注册的时间就不可能在被监听了这个时候出现问题的

![](https://gitee.com/hxc8/images8/raw/master/img/202407191107573.jpg)





process 



简介

![](https://gitee.com/hxc8/images8/raw/master/img/202407191107632.jpg)






正则表达式用于字符串处理、表单验证等场合，实用高效。本文收集了一些常用的表达式：

view sourceprint?

$str= preg_replace("/( )(.*?)(<\/a>)/" , '\1\2\3', $str);

其中用了三个子模式（每个圆括号中内容为一个子模式），第一个是链接开始标签，第二个是链接文本，第三个是

然后第二个参数中\1、\2、\3就表示这三个部分，要替换成什么样子还不简单？

获取页面中的所有链接地址的PHP函数

下面这个用PHP写的函数,可以获取任意的字符串$string中的所有链接地址($string可以是从一个HTML页面文件直接读取出来的字符串),结果保存在一个数组中返回.该函数自动把电子邮件地址排除在外,而且返回的数组中不会有重复元素.

view source

print?

functionGetAllLink($string)

{

$string= str_replace("\r","",$string);

$string= str_replace("\n","",$string);

$regex[url] = "((http|https|ftp|telnet|news):\/\/)?([a-z0-9_\-\/\.]+\.[][a-z0-9:;&#@=_~%\?\/\.\,\+\-]+)";

$regex[email] = "([a-z0-9_\-]+)@([a-z0-9_\-]+\.[a-z0-9\-\._\-]+)";

//去掉标签之间的文字

$string= eregi_replace(">[^<>]+<","><", $string);

//去掉JAVASCRIPT代码

$string= eregi_replace("","", $string);

//去掉非的HTML标签

$string= eregi_replace("<[^a][^<>]*>","", $string);

//去掉EMAIL链接

$string= eregi_replace(" ]*>" ,"", $string);

//替换需要的网页链接

$string= eregi_replace(" ]*>" ,"\\3\t", $string);

$output[0] = strtok($string, "\t");

while(($temp= strtok("\t")))

{

if($temp&& !in_array($temp, $output))

$output[++$i] = $temp;

}

return$output;

}

以下是以PHP的语法所写的示例

验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间

view sourceprint?

$str= 'a1234';

if(preg_match("^[a-zA-Z0-9]{4,16}$", $str)) {

echo"验证成功";} else{

echo"验证失敗";}?>

简易的台湾身分证字号验证

view source

print?

$str= 'a1234';

if(preg_match("^(?:\d{15}|\d{18})$", $str)) {

echo"验证成功";

} else{

echo"验证失敗";}

?>

下面的代码实现文字中的代码块，功能就如你在脚本之家看到的代码一样。

view sourceprint?

functioncodedisp($code) {

global$discuzcodes;

$discuzcodes['pcodecount']++;

$code= htmlspecialchars(str_replace('\\"', '"', preg_replace("/^[\n\r]*(.+?)[\n\r]*$/is", "\\1", $code)));

$discuzcodes['codehtml'][$discuzcodes['pcodecount']] = "

[复制此代码]

代码如下:

".fhtml2($code)."



";

$discuzcodes['codecount']++;

return"[\tDISCUZ_CODE_$discuzcodes[pcodecount]\t]";

}

$message= preg_replace("/\s*\[code\](.+?)\[\/code\]\s*/ies", "codedisp('\\1')", $message);

$message= preg_replace("/\s*\[html\](.+?)\[\/html\]\s*/ies", "htmldisp('\\1')", $message);

匹配中文字符的正则表达式： [\u4e00-\u9fa5]

评注：匹配中文还真是个头疼的事，有了这个表达式就好办了

匹配双字节字符(包括汉字在内)：[^\x00-\xff]

评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）

匹配空白行的正则表达式：\n\s*\r

评注：可以用来删除空白行

匹配HTML标记的正则表达式：<(\S*?)[^>]*>.*?|<.*? />

评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力

匹配首尾空白字符的正则表达式：^\s*|\s*$

评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式

匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

评注：表单验证时很实用

匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*

评注：网上流传的版本功能很有限，上面这个基本可以满足需求

匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

评注：表单验证时很实用

匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}

评注：匹配形式如 0511-4405222 或 021-87888822

匹配腾讯QQ号：[1-9][0-9]{4,}

评注：腾讯QQ号从10000开始

匹配中国邮政编码：[1-9]\d{5}(?!\d)

评注：中国邮政编码为6位数字

匹配身份证：\d{15}|\d{18}

评注：中国的身份证为15位或18位

匹配ip地址：\d+\.\d+\.\d+\.\d+

评注：提取ip地址时有用

匹配特定数字：

^[1-9]\d*$　 　 //匹配正整数 ^-[1-9]\d*$ 　 //匹配负整数 ^-?[1-9]\d*$　　 //匹配整数 ^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0） ^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0） ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$　　 //匹配正浮点数 ^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$　 //匹配负浮点数 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$　 //匹配浮点数 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$　　 //匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$　　//匹配非正浮点数（负浮点数 + 0）

评注：处理大量数据时有用，具体应用时注意修正

匹配特定字符串：

^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串 ^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串 ^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串 ^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串

下面是一些特殊字符：

正则表达式中的特殊字符： （学习参考书－＜＜精通正则表达式＞＞）

字符

意义：对于字符，通常表示按字面意义，指出接着的字符为特殊字符，不作解释。

例如：/b/匹配字符'b',通过在b 前面加一个反斜杠，也就是/b/，则该字符变成特殊字符，表示

匹配一个单词的分界线。

或者：

对于几个字符，通常说明是特殊的，指出紧接着的字符不是特殊的，而应该按字面解释。

例如：*是一个特殊字符，匹配任意个字符(包括0个字符)；例如：/a*/意味匹配0个或多个a。

为了匹配字面上的*，在a前面加一个反斜杠；例如：/a*/匹配'a*'。

字符^

意义：表示匹配的字符必须在最前边。

例如：/^A/不匹配"an A,"中的'A'，但匹配"An A."中最前面的'A'。

字符$

意义：与^类似，匹配最末的字符。

例如：/t$/不匹配"eater"中的't'，但匹配"eat"中的't'。

字符*

意义：匹配*前面的字符0次或n次。

例如:/bo*/匹配"A ghost booooed"中的'boooo'或"A bird warbled"中的'b'，但不匹配"A goat g

runted"中的任何字符。

字符+

意义：匹配+号前面的字符1次或n次。等价于{1,}。

例如：/a+/匹配"candy"中的'a'和"caaaaaaandy."中的所有'a'。

字符?

意义：匹配?前面的字符0次或1次。

例如：/e?le?/匹配"angel"中的'el'和"angle."中的'le'。

字符.

意义：(小数点)匹配除换行符外的所有单个的字符。

例如：/.n/匹配"nay, an apple is on the tree"中的'an'和'on'，但不匹配'nay'。

字符(x)

意义：匹配'x'并记录匹配的值。

例如：/(foo)/匹配和记录"foo bar."中的'foo'。匹配子串能被结果数组中的素[1], ..., [n] 返

回，或被RegExp对象的属性$1, ..., $9返回。

字符x|y

意义：匹配'x'或者'y'。

例如：/green|red/匹配"green apple"中的'green'和"red apple."中的'red'。

字符{n}

意义：这里的n是一个正整数。匹配前面的n个字符。

例如：/a{2}/不匹配"candy,"中的'a'，但匹配"caandy," 中的所有'a'和"caaandy."中前面的两个

'a'。

字符{n,}

意义：这里的n是一个正整数。匹配至少n个前面的字符。

例如：/a{2,}不匹配"candy"中的'a'，但匹配"caandy"中的所有'a'和"caaaaaaandy."中的所有'a'

字符{n,m}

意义：这里的n和m都是正整数。匹配至少n个最多m个前面的字符。

例如：/a{1,3}/不匹配"cndy"中的任何字符，但匹配 "candy,"中的'a'，"caandy," 中的前面两个

'a'和"caaaaaaandy"中前面的三个'a'，注意：即使"caaaaaaandy" 中有很多个'a'，但只匹配前面的三

个'a'即"aaa"。

字符[xyz]

意义：一字符列表，匹配列出中的任一字符。你可以通过连字符-指出一个字符范围。

例如：[abcd]跟[a-c]一样。它们匹配"brisket"中的'b'和"ache"中的'c'。

字符[^xyz]

意义：一字符补集，也就是说，它匹配除了列出的字符外的所有东西。 你可以使用连字符-指出一

字符范围。

例如：[^abc]和[^a-c]等价，它们最早匹配"brisket"中的'r'和"chop."中的'h'。

字符

意义：匹配一个空格(不要与b混淆)

字符b

意义：匹配一个单词的分界线，比如一个空格(不要与混淆)

例如：/bnw/匹配"noonday"中的'no'，/wyb/匹配"possibly yesterday."中的'ly'。

字符B

意义：匹配一个单词的非分界线

例如：/wBn/匹配"noonday"中的'on'，/yBw/匹配"possibly yesterday."中的'ye'。

字符cX

意义：这里的X是一个控制字符。匹配一个字符串的控制字符。

例如：/cM/匹配一个字符串中的control-M。

字符d

意义：匹配一个数字，等价于[0-9]。

例如：/d/或/[0-9]/匹配"B2 is the suite number."中的'2'。

字符D

意义：匹配任何的非数字，等价于[^0-9]。

例如：/D/或/[^0-9]/匹配"B2 is the suite number."中的'B'。

字符f

意义：匹配一个表单符

字符n

意义：匹配一个换行符

字符r

意义：匹配一个回车符

字符s

意义：匹配一个单个white空格符，包括空格，tab，form feed，换行符，等价于[ fnrtv]。

例如：/sw*/匹配"foo bar."中的' bar'。

字符S

意义：匹配除white空格符以外的一个单个的字符，等价于[^ fnrtv]。

例如：/S/w*匹配"foo bar."中的'foo'。

字符t

意义：匹配一个制表符

字符v

意义：匹配一个顶头制表符

字符w

意义：匹配所有的数字和字母以及下划线，等价于[A-Za-z0-9_]。

例如：/w/匹配"apple,"中的'a'，"$5.28,"中的'5'和"3D."中的'3'。

字符W

意义：匹配除数字、字母外及下划线外的其它字符，等价于[^A-Za-z0-9_]。

例如：/W/或者/[^$A-Za-z0-9_]/匹配"50%."中的'%'。

字符n

意义：这里的n是一个正整数。匹配一个正则表达式的最后一个子串的n的值(计数左圆括号)。

例如：/apple(,)sorange1/匹配"apple, orange, cherry, peach."中的'apple, orange'，下面

有一个更加完整的例子。

注意：如果左圆括号中的数字比n指定的数字还小，则n取下一行的八进制escape作为描述。

字符ooctal和xhex

意义：这里的ooctal是一个八进制的escape值，而xhex是一个十六进制的escape值，允许在一个正则表达式中嵌入ASCII码。

通用模式

定界符，通常使用 "/"做为定界符开始和结束,也可以使用"#"。

什么时候使用"#"呢?一般是在你的字符串中有很多"/"字符的时候，因为正则的时候这种字符需要转义，比如uri。

使用"/"定界符的代码如下.

view source

print?

$regex= '/^http://([w.]+)/([w]+)/([w]+).html$/i';

$str= 'http://www.youku.com/show_page/id_ABCDEFG.html';

$matches= array();

if(preg_match($regex, $str, $matches)){

var_dump($matches);

}

echo"n";

preg_match中的$matches[0]将包含与整个模式匹配的字符串。

使用"#"定界符的代码如下.这个时候对"/"就不转义!

view sourceprint?

$regex= '#^http://([w.]+)/([w]+)/([w]+).html$#i';

$str= 'http://www.youku.com/show_page/id_ABCDEFG.html';

$matches= array();

if(preg_match($regex, $str, $matches)){

var_dump($matches);

}

echo"n";

修饰符:用于改变正则表达式的行为。

我们看到的('/^http://([w.]+)/([w]+)/([w]+).html/i')中的最后一个"i"就是修饰符,表示忽略大小写，还有一个我们经常用到的是"x"表示忽略空格。

贡献代码:

view source

print?

$regex= '/HELLO/';

$str= 'hello word';

$matches= array();

if(preg_match($regex, $str, $matches)){

echo'No i:Valid Successful!',"n";

}

if(preg_match($regex.'i', $str, $matches)){

echo'YES i:Valid Successful!',"n";

}

字符域:[w]用方括号扩起来的部分就是字符域。

限定符:如[w]{3,5}或者[w]*或者[w]+这些[w]后面的符号都表示限定符。现介绍具体意义。

{3,5}表示3到5个字符。{3,}超过3个字符，{,5}最多5个，{3}三个字符。

* 表示0到多个

+ 表示1到多个。

脱字符号

^:

> 放在字符域(如:[^w])中表示否定(不包括的意思)——“反向选择”

> 放在表达式之前，表示以当前这个字符开始。(/^n/i,表示以n开头)。

注意，我们经常管""叫"跳脱字符"。用于转义一些特殊符号，如".","/"

界符：正则表达式的形式一般如下：

/love/

其中位于“/”定界符之间的部分就是将要在目标对象中进行匹配的模式。

元字符：就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式。

较为常用的元字符包括： “+”， “*”，以及 “?”。

“+”元字符规定其前导字符必须在目标对象中连续出现一次或多次

“*”元字符规定其前导字符必须在目标对象中出现零次或连续多次，

“?”元字符规定其前导字符必须在目标对象中连续出现零次或一次。

下面，就让我们来看一下正则表达式元字符的具体应用。

/fo+/

因为上述正则表达式中包含“+”元字符（它前面的“o”是前导字符），表示可以与目标对象中的“fool”, “fo”等在字母f后面连续出现一个或多个字母o的字符串相匹配。

除了元字符之外，用户还可以精确指定模式在匹配对象中出现的频率。例如，

/jim{2,6}/

上述正则表达式规定字符m可以在匹配对象中连续出现2-6次，因此，上述正则表达式可以同jimmy或jimmmmmy等字符串相匹配。

其它几个重要的元字符的使用方式。

s：用于匹配单个空格符，包括tab键和换行符；

S：用于匹配除单个空格符之外的所有字符；

d：用于匹配从0到9的数字；

w：用于匹配字母，数字或下划线字符；

W：用于匹配所有与w不匹配的字符；

. ：用于匹配除换行符之外的所有字符。

（说明：我们可以把s和S以及w和W看作互为逆运算）

下面，我们就通过实例看一下如何在正则表达式中使用上述元字符。

/s+/

上述正则表达式可以用于匹配目标对象中的一个或多个空格字符。

除了我们以上所介绍的元字符之外，正则表达式中还具有另外一种较为独特的专用字符，即定位符。

定位符：用于规定匹配模式在目标对象中的出现位置。

较为常用的定位符包括： “^”, “$”, “b” 以及 “B”。

“^”定位符规定匹配模式必须出现在目标字符串的开头

“$”定位符规定匹配模式必须出现在目标对象的结尾

b定位符规定匹配模式必须出现在目标字符串的开头或结尾的两个边界之一

“B”定位符则规定匹配对象必须位于目标字符串的开头和结尾两个边界之内，即匹配对象既不能作为目标字符串的开头，也不能作为目标字符串的结尾。同样，我们

也可以把“^”和“$”以及“b”和“B”看作是互为逆运算的两组定位符。举例来说：

/^hell/

因为上述正则表达式中包含“^”定位符，所以可以与目标对象中以 “hell”, “hello”或 “hellhound”开头的字符串相匹配。

/ar$/

因为上述正则表达式中包含“$”定位符，所以可以与目标对象中以 “car”, “bar”或 “ar” 结尾的字符串相匹配。

/bbom/

因为上述正则表达式模式以“b”定位符开头，所以可以与目标对象中以 “bomb”, 或 “bom”开头的字符串相匹配。

/manb/

因为上述正则表达式模式以“b”定位符结尾，所以可以与目标对象中以 “human”, “woman”或 “man”结尾的字符串相匹配。

为了能够方便用户更加灵活的设定匹配模式，正则表达式允许使用者在匹配模式中指定某一个范围而不局限于具体的字符。例如：

/[A-Z]/

上述正则表达式将会与从A到Z范围内任何一个大写字母相匹配。

/[a-z]/

上述正则表达式将会与从a到z范围内任何一个小写字母相匹配。

/[0-9]/

上述正则表达式将会与从0到9范围内任何一个数字相匹配。

/([a-z][A-Z][0-9])+/

上述正则表达式将会与任何由字母和数字组成的字符串，如 “aB0” 等相匹配。这里需要提醒用户注意的一点就是可以在正则表达式中使用 “()” 把字符串组合在一起。

“()”符号：包含的内容必须同时出现在目标对象中。因此，上述正则表达式将无法与诸如 “abc”等的字符串匹配，因为“abc”中的最后一个字符为字母而非数字。

如果我们希望在正则表达式中实现类似编程逻辑中的“或”运算，在多个不同的模式中任选一个进行匹配的话，可以使用管道符： “|”。例如：

/to|too|2/

上述正则表达式将会与目标对象中的 “to”, “too”, 或 “2” 相匹配。

否定符：“[^]”。与我们前文所介绍的定位符 “^” 不同，否定符 “[^]”规定目标对象中不能存在模式中所规定的字符串。例如：

/[^A-C]/

上述字符串将会与目标对象中除A，B，和C之外的任何字符相匹配。一般来说，当“^”出现在 “[]”内时就被视做否定运算符；而当“^”位于“[]”之外，或没有“[]”时，则应当被视做定位符。

最后，当用户需要在正则表达式的模式中加入元字符，并查找其匹配对象时，可以使用

转义符：“”。例如：

/Th*/

上述正则表达式将会与目标对象中的“Th*”而非“The”等相匹配。

实际经验介绍

还是得说说 ^ 和 $ 他们是分别用来匹配字符串的开始和结束，以下分别举例说明：

“^The”：开头一定要有”The”字符串；

“of despair$”：结尾一定要有”of despair” 的字符串；

那么，

“^abc$”：就是要求以abc开头和以abc结尾的字符串，实际上是只有abc匹配；

“notice”：匹配包含notice的字符串；

你可以看见如果你没有用我们提到的两个字符（最后一个例子），就是说模式（正则表达式）可以出现在被检验字符串的任何地方，你没有把他锁定到两边。

接着，说说 ‘*' ‘+' 和 ‘?'

他们用来表示一个字符可以出现的次数或者顺序，他们分别表示：

“zero or more”相当于{0,}

“one or more”相当于{1,}

“zero or one.”相当于{0,1}

这里是一些例子：

“ab*”：和ab{0,}同义，匹配以a开头，后面可以接0个或者N个b组成的字符串(”a”, “ab”, “abbb”, 等)；

“ab+”：和ab{1,}同义，同上条一样，但最少要有一个b存在 (”ab” “abbb”等)；

“ab?”：和ab{0,1}同义，可以没有或者只有一个b；

“a?b+$”：匹配以一个或者0个a再加上一个以上的b结尾的字符串。

要点：'*' ‘+' 和 ‘?' 只管它前面那个字符。

你也可以在大括号里面限制字符出现的个数，比如：

“ab{2}”: 要求a后面一定要跟两个b（一个也不能少）(”abb”)；

“ab{2,}”: 要求a后面一定要有两个或者两个以上b(如”abb” “abbbb” 等)；

“ab{3,5}”: 要求a后面可以有2－5个b(”abbb”, “abbbb”, or “abbbbb”)。

现在我们把一定几个字符放到小括号里，比如：

“a(bc)*”: 匹配 a 后面跟0个或者一个”bc”；

“a(bc){1,5}”: 一个到5个 “bc”；

还有一个字符 ‘|'，相当于OR操作：

“hi|hello”: 匹配含有”hi” 或者 “hello” 的 字符串；

“(b|cd)ef”: 匹配含有 “bef” 或者 “cdef”的字符串；

“(a|b)*c”: 匹配含有这样多个（包括0个）a或b，后面跟一个c的字符串；

一个点('.')可以代表所有的单一字符，不包括” ”

如果，要匹配包括” ”在内的所有单个字符，怎么办？

用'[ .]'这种模式。

“a.[0-9]”: 一个a加一个字符再加一个0到9的数字；

“^.{3}$”: 三个任意字符结尾。

中括号括住的内容只匹配一个单一的字符

“[ab]”: 匹配单个的 a 或者 b ( 和 “a│b” 一样)；

“[a-d]”: 匹配'a' 到'd'的单个字符 (和”a│b│c│d” 还有 “[abcd]”效果一样)；

一般我们都用[a-zA-Z]来指定字符为一个大小写英文：

“^[a-zA-Z]”: 匹配以大小写字母开头的字符串；

“[0-9]%”: 匹配含有 形如 x％ 的字符串；

“,[a-zA-Z0-9]$”: 匹配以逗号再加一个数字或字母结尾的字符串；

你也可以把你不想要得字符列在中括号里，你只需要在总括号里面使用'^' 作为开头 “%[^a-zA-Z]%” 匹配含有两个百分号里面有一个非字母的字符串。

要点：^用在中括号开头的时候，就表示排除括号里的字符。

为了PHP能够解释，你必须在这些字符面前后加”，并且将一些字符转义。

不要忘记在中括号里面的字符是这条规路的例外—在中括号里面，所有的特殊字符，包括(”)，都将失去他们的特殊性质 “[*+?{}.]”匹配含有这些字符的字符串：

还有，正如regx的手册告诉我们：”如果列表里含有']'，最好把它作为列表里的第一个字符(可能跟在'^'后面)。如果含有'-'，最好把它放在最前面或者最后面

， or 或者一个范围的第二个结束点[a-d-0-9]中间的‘-'将有效。

看了上面的例子，你对{n,m}应该理解了吧。要注意的是，n和m都不能为负整数，而且n总是小于m。这样，才能 最少匹配n次且最多匹配m次。如”p{1,5}”将匹配

“pvpppppp”中的前五个p

下面说说以开头的

b 书上说他是用来匹配一个单词边界，就是…比如'veb'，可以匹配love里的ve而不匹配very里有ve

B 正好和上面的b相反。

正则表达式的其他用法

提取字符串

ereg() and eregi() 有一个特性是允许用户通过正则表达式去提取字符串的一部分(具体用法你可以阅读手册)。比如说，我们想从 path/URL 提取文件名，下面的代

码就是你需要：

ereg(”([^\/]*)$”, $pathOrUrl, $regs);

echo $regs[1];

高级的代换

ereg_replace() 和 eregi_replace()也是非常有用的，假如我们想把所有的间隔负号都替换成逗号：

ereg_replace(”[ t]+”, “,”, trim($str));

以下为引用的内容：

view sourceprint?

preg_match()和preg_match_all()

preg_quote()

preg_split()

preg_grep()

preg_replace()

函数的具体使用，我们可以通过PHP手册来找到，下面分享一些平时积累的正则表达式：

匹配action属性

以下为引用的内容：

view source

print?

$str= '';

$match= '';

preg_match_all('/s+action="(?!http:)(.*?)"s/', $str, $match);

print_r($match);

在正则中使用回调函数

以下为引用的内容：

view sourceprint?

/**

* replace some string by callback function

*

*/

functioncallback_replace() {

$url= 'http://esfang.house.sina.com.cn';

$str= '';

$str= preg_replace ( '/(?<=saction=")(?!http:)(.*?)(?="s)/e', 'search($url, \1)', $str);

echo$str;

}

functionsearch($url, $match){

return$url. '/'. $match;

}

带断言的正则匹配

view source

print?

$match= '';

$str= 'xxxxxx.com.cn bold font

paragraph text

';

preg_match_all ( '/(?<=<(w{1})>).*(?=)/', $str, $match);

echo"匹配没有属性的HTML标签中的内容：";

print_r ( $match);

替换HTML源码中的地址

以下为引用的内容：

view sourceprint?

$form_html= preg_replace ( '/(?<=saction="|ssrc="|shref=")(?!http:|javascript)(.*?)(?="s)/e', 'add_url($url, '\1')', $form_html);

元字符

在上面的例子中，^ 、d 及 $ 等这些符号，代表了特定的匹配意义，我们称之为元字符，常用的元字符如下：

元字符 说明

. 匹配除换行符意外的任意字符

w 匹配字母或数字或下划线

s 匹配任意的空白符

d 匹配数字

b 匹配单词的开始或结束

^ 匹配字符串的开始

$ 匹配字符串的结束

[x] 匹配x字符，如匹配字符串中的 a、b 和 c 字符

W w的反义，即匹配任意非字母，数字，下划线和汉字的字符

S s的反义，即匹配任意非空白符的字符

D d的反义，即匹配任意非数字的字符

B b的反义，即不是单词开头或结束的位置

[^x] 匹配除了 x 意外的任意字符，如 [^abc] 匹配除了 abc 这几个字母之外的任意字符
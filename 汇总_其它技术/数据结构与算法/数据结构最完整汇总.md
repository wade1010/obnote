1 数据结构简介

数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作；

不同的数据结构具有各自对应的适用场景，旨在降低各种算法计算的时间与空间复杂度，达到最佳的任务执行效率；

分类

数据结构可分为线性数据结构与非线性数据结构；

线性数据结构：数组、链表、栈、队列；

非线性数据结构：树、堆、散列表、图；

![](https://gitee.com/hxc8/images6/raw/master/img/202407190016304.jpg)

**数组**：是一种线性表结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

**链表**：它并不需要一块连续的内存空间，他通过"指针"将一组零散的内存块串联起来使用，所以如果我们申请的是100MB大小的链表，根本不会有问题。三种常见链表是：**单链表，双向链表，循环链表**

**栈：**后进者先出，先进者后出。 如：浏览器的前进，后退；函数调用栈。 栈是一种“操作受限“”的线性表，只允许在一端插入和删除数据

**队列**：先进者先出。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队（放入队列尾部），出队（从队列头部取一个元素），所以队列也是一种操作受限的线性表数据结构

**二分查找算法（前提：顺序表结构--数组&&有序数据集合）：确定中间元素，对半分，循环继续查找，直到找到元素返回。特点：1. 顺序表结构  2. 有序数据 3. 数据量太小不适合二分查找（数据量小直接遍历就行）  4. 数据量太大也不适合二分查找 （二分查找依赖的数组数据结构要求内存的连续性）**

**二分查找变形问题：查找一个值等于给定值得元素，查找最后一个值等于给定值得元素，查找第一个大于给定值得元素**

**跳表（redis有序集合有使用）：可以快速实现插入，删除，查找操作。写起来也不复杂，甚至可以代替红黑树**

跳表的实现：链表存储有序数据，增加索引层（即可使用分治思想）。查找某个节点时，先遍历索引缩小查询范围（空间换时间的设计思路）

跳表索引的动态更新问题：为了避免复杂度退化，如果链表中的节点多了，索引节点就相应的增加一些。我们可以通过随机函数选择将这个数据插入到部分索引层中

**散列表（hash表或者哈希表）：散列表用的是数组支持按照下标随机访问数据的特性，所以所以散列表其实就是数组的一种扩展，由数组演化而来。可以说如果没有数组就没有散列表**

散列冲突问题：因为数组的存储空间有限，也会加大散列冲突的概率。1. 开放寻址法(如： java中的ThreadLocalMap)：如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。重新探测的方法--线性探测。查找元素时也是先根据key找到角标，然后判断元素属性判断是否是需要查找的元素，要是不是则顺着角标继续往后查找，知道查到对应元素。如果没找到，则元素没有在列表中 2. 链表法（更加常用，如：java中LinkedHashMap）：散步表中每一个槽（key）会对应一条链表，插入时通过散列函数计算到角标，然后插入到槽内对应的链表中，查找和删除时也是先找到槽位，然后对链表进行查找和删除。比较适合存储大对象，大数据量的散列表，也更加灵活，支持更多的优化策略

**二叉树：存储方式：基于链表的链式存储，基于数组的顺序存储**

**满二叉树：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点**

**二叉树查找树：**

**描述：在树的任意一个节点，其左子树的节点的值都小于这个节点的值，而右子树节点的值都大于这个节点的值。**

**查找方法：递归二分查找， 为了避免时间复杂度的退化（链表），又设计了一种更复杂的树，平衡二叉树查找树（ALV树）。**

**红黑树：是平衡二叉树查找树的性能妥协版本**

**堆：是一个完全二叉树，树的节点的值必须大于等于（或小于等于）每个节点的值，这个特点使得堆就是天然的一个从上往下排好序的。堆顶就是最大值或者最小值。排序方便，插入和删除就比较麻烦，插入就是一个比较堆化的过程。**

**函数递归也叫递归树**

**b+树：树有多个叶子节点，下面一层是数据，上面各层是索引（和跳表有点类似），如mysql的索引使用**

作者：_WANGbin_

链接：[https://www.jianshu.com/p/532ab41c6cb5](https://www.jianshu.com/p/532ab41c6cb5)

来源：简书

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
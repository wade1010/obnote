1、网络服务器的演进

1）单进程阻塞的网络服务器 ，如下图所示：

![](https://gitee.com/hxc8/images7/raw/master/img/202407190025216.jpg)



说明：

1、创建一个socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤

2、进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入睡眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket

3、利用fread读取客户端socket当中的数据收到数据后服务器程序进行处理然后使用fwrite向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。

缺点：

1、一次只能处理一个连接，不支持多个连接同时处理，每个连接进入到我们的服务端的时候,单独创建一个进程/线程提供服务



2）预派生子进程模式



![](https://gitee.com/hxc8/images7/raw/master/img/202407190025854.jpg)





说明：

前面流程一致就不补充了

1、程序启动后就会创建N个进程。每个子进程进入 Accept，等待新的连接进入。当客户端连接到服务器时，其中一个子进程会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当此连接关闭时，子进程会释放，重新进入 Accept，参与处理新的连接。

这个模型的优势是完全可以复用进程，不需要太多的上下文切换，比如php-fpm基于此模型的。

 

缺点：

1、这种模型严重依赖进程的数量解决并发问题，一个客户端连接就需要占用一个进程，工作进程的数量有多少，并发处理能力就有多少。操作系统可以创建的进程数量是有限的。

 

2、操作系统生成一个子进程需要进行内存复制等操作，在资源和时间上会产生一定的开销；当有大量请求时，会导致系统性能下降；

 

 例如：即时聊天程序，一台服务器可能要维持数十万的连接，那么就要启动数十万的进程来维持。这显然不可能

 

基于上面的模式我们发现我们只能通过每次（accept）处理单个请求，没办法一次性处理多个请求？





 

3）单进程阻塞复用的网络服务器 ，如下图所示

![](https://gitee.com/hxc8/images7/raw/master/img/202407190025198.jpg)

说明：

服务监听流程如上

1、保存所有的socket,通过select模型，监听socket描述符的可读事件

2、Select会在内核空间监听一旦发现socket可读，会从内核空间传递至用户空间，在用户空间通过逻辑判断是服务端socket可读，还是客户端的socket可读

3、如果是服务端的socket可读，说明有新的客户端建立，将socket保留到监听数组当中

4、如果是客户端的socket可读，说明当前已经可以去读取客户端发送过来的内容了，读取内容，然后响应给客户端。

  缺点：

1、select模式本身的缺点（1、循环遍历处理事件、2、内核空间传递数据的消耗）

2、单进程对于大量任务处理乏力





4）多进程master-worker模型



![](https://gitee.com/hxc8/images7/raw/master/img/202407190025791.jpg)




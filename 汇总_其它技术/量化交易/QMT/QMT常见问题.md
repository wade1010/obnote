QMT常见问题

[http://docs.thinktrader.net/vip/pages/cc95b6/#_1-%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E7%AD%96%E7%95%A5%E6%88%96%E6%8C%87%E6%A0%87](http://docs.thinktrader.net/vip/pages/cc95b6/#_1-%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E7%AD%96%E7%95%A5%E6%88%96%E6%8C%87%E6%A0%87)

## QMT终端相关

该报错是由于券商后台开启了Python库白名单，若您使用的是券商提供的QMT终端，请联系您的所属券商开通对应Python库白名单权限即可。

1、科创板，连续交易时段限价单笔最大是10万股，市价单笔最大是5万股，盘后定价交易单笔最大量是100万股，200股起，1股递增。 2、创业板，连续交易时段限价单笔最大30万股，市价单笔最大15万股，100股起，100股递增。 3、主板，6和0开头的，连续交易时段单笔最大100万股，100股起，100股递增。

ContextInfo是由底层维护并传递给init、handlebar等系统函数的参数，同一个bar（不是bar里面的tick，下同）内ContextInfo本质上是同一个变量且对其进行的修改只会对本次handlebar调用的下文所起作用。handlebar里对ContextInfo做的修改在该bar结束后才会进行保存，也就是说，对ContextInfo做的修改会在下一个bar体现出来。

具体来说，ContextInfo不同于一般python对象，做了逐k线更新设计，盘中主图品种每个level1分笔到达会触发handlebar函数调用，但只有k线结束时最后一个分笔触发的handlebar调用，对ContextInfo的修改才有效。每次handlebar函数调用前会对ContextInfo对象进行深拷贝, 下一次分笔行情到来时，如果新的分笔不是新k线bar第一个分笔，则判断上一个分笔不是k线最后分笔，ContextInfo对象被回退为之前深拷贝的那个. ContextInfo对象逐k线更新机制设计的目的，是为了在盘中时模拟k线的效果，只在k线结束的分笔触发的handlebar函数运行时生效一次，丢弃所有其他分笔的修改。 该机制有两个影响，一是在ContextInfo对象中存数据每次分笔到达时会被深拷贝，拖慢策略运行；二是ContextInfo适用于记录逐k线生效的交易信号（quickTrade参数传0），不适宜立刻下单的情况。 如不需要模拟k线效果，希望调用交易函数后立刻下单，quickTrade参数可以传2， 下单记录可以用普通的全局变量保存, 不能存在ContextInfo对象的属性里(实现可以参考实盘示例7-调整至目标持仓Demo)。

下单函数passorder有可选参数 快速交易quickTrade， 默认为0. 传0， 只在k线结束分笔时调用passorder产生有效信号，其他情况调用不产生信号。 传1，在当前k线为最新k线时调用passorder函数产生有效信号, 历史k线调用不产生信号。传2， 任何情况下调用passorder都产生有效信号，不会丢弃任何一次调用的信号。如果在定时器注册的回调函数，行情回调函数, after_init函数中调用下单函数，需要传2，确保不会漏单。

为保证以尽快的速度执行交易信号, qmt客户端提供的交易接口是异步的, 以快速交易参数填2的passorder函数为例，调用后会立刻发出委托, 然后返回。不会等待委托回报, 也不会阻塞python线程的运行。

委托/成交/持仓/账号信息的更新, 是在客户端后台进行的, python策略中无法手动控制。python提供的取账号信息接口 get_trade_detail_data， 与四种交易回调函数, 都是从客户端本地缓存中读取数据 / 触发调用，不是调用时查询柜台再返回。客户端本地缓存状态定期接收柜台推送刷新，有交易主推的柜台50ms一次，没有交易主推的柜台1-6秒一次。 不能认为get_trade_detail_data查到的状态是与柜台完全一致的, 比如卖出委托后立刻查询, 不会查到对应委托, 可用资金也不会变多。

实盘策略需要设计盘中保存/更新委托状态的机制。常见的做法是用全局变量字典保存委托状态, 给每一笔委托独立的投资备注作为字典的key，委托状态作为字典的value, 下单后默认设置为待报, 之后查到委托后更新状态。如果某品种股票存在待报状态委托, 暂停该品种后续报单, 防止发生超单的情况。(实现可以参考实盘示例7-调整至目标持仓Demo)

(QMT所有策略是在同一个线程中被调用的，任意一个策略阻塞线程(死循环 sleep 加锁等操作)会导致所有策略的执行被阻塞，所以不能在策略里写等待操作。如需要多线程 / 多进程的用法，可以使用极简模式配合xtquant库使用)

1、检查是否是在模型交易界面，实盘模式运行的策略。模拟模式只显示策略信号，不发出委托。

2、如运行到交易函数，未看到策略信号，检查交易函数是否使用了快速下单参数(quickTrade)，默认为0，只会在k线结束发出委托，日线及以上周期等于全天不会委托。传2，运行到交易函数时立刻发出委托。

3、如看到实盘的策略信号，未找到对应委托，检查客户端左下角消息提示是否有报错，如有，请根据消息提示的描述修改下单参数

QMT行情数据主要分为三种，包括本地数据，全推数据，订阅数据。 本地数据指通过下载数据功能下载到本地的行情数据加密文件，全推数据指客户端启动后自动会接收的全市场最新行情数据快照（只有最新值数据，没有历史数据，数据50ms增量更新一次）,订阅指向行情服务器订阅指定品种行情（有当天的历史数据 当天以前的需要用down_history_data下），初次订阅速度慢 有最大数量限制(一定数量支标的+周期)。 全推数据用get_full_tick接口获取, 或subscribe_whole_quote传入回调函数; 本地数据用get_market_data_ex函数，subscribe参数传False获取; 订阅数据用subscibe_quote接口订阅, get_market_data_ex接口获取.

- down_history_data 下载指定区间的行情数据到本地，存放在硬盘上。效果和界面,点击行情数据下载一致。 开始时间不填时，为增量下载(以本地数据最后一天为开始时间), 填写的话按填写值下载。

- get_local_data 取本地数据函数，盘中不会更新，速度快，回测可以用这个函数取。

- get_full_tick 取客户端缓存中的最新全推数据。全推数据不包括历史，不用订阅，没有品种数量限制，盘中50ms更新一次，速度快。

- subscribe_quote 向服务器订阅股票行情 盘中实时更新 初次订阅耗时长，最大订阅品种数受限. 订阅超过一定数量的品种k线行情不会更新.可订阅四种基本周期(分笔 一分钟 五分钟 日线)行情（如果有level2行情权限 也可以订level2的）, 同一品种订阅了不同周期累加计数(如订阅浦发银行 1分钟 5分钟 日线行情 算订阅3次). 复数策略订阅同一品种计数不会累加. level2的订阅也会受限，但是和level1的互不影响。

- unsubscribe_quote 按订阅号反订阅行情, 释放可订阅数.

- get_market_data_ex 取订阅/本地数据接口。用subscribe_quote在init函数中先订阅后/subscribe参数为True时，取本地数据和订阅的最新行情。subscribe参数传False时,可以用来取本地数据，不会订阅。 如股票池超过一定数量，可用 down_history_data + get_local_data + get_full_tick 拼接历史和最新数据替代get_market_data_ex。

- (set_universe, get_history_data, get_market_data 是早期订阅股票池, 取订阅的行情数据接口. 因为set_universe订阅的品种没有订阅号 无法在策略中反订阅, 只能通过停止策略释放订阅数. 不再推荐使用.)

修改行情源对应的全推行情级别，见下图  或

![](https://gitee.com/hxc8/images5/raw/master/img/202407172350220.jpg)

![](https://gitee.com/hxc8/images5/raw/master/img/202407172350148.jpg)
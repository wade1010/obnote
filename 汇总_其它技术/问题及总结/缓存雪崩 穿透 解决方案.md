缓存雪崩的原因及解决方案

        1、缓存大面积失效

        解决方案：避免缓存设置相近的有效期；为有效期增加随机值；统一规划有效期，失效时间均匀分布。

        2、对热点数据持续高并发

        解决方案：使用互斥锁：jvm锁机制；分布式锁机制。

        3、有效期本身的缺陷

        解决方案：缓存永不过期，异步更新。

        优点：不阻塞线程，用户体验好，不会出现雪崩效应。

        缺点：不保证一致性，代码复杂度增大（每个value值都要维护异步更新代码），容易堆积垃圾数据。



双缓存方案

        主缓存：有效期按照经验值设置，主要读取的缓存，主缓存失效后从数据库加载最新值。

        备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。

        其实就是缓存降级策略。





缓存击穿的解决方案：

当访问数据库中不存在的数据时，可以给这个key设置一个固定值，并设置过期时间，这样的话，大量的访问该key的请求，都被缓存挡住了；当key存在数据时，缓存也已经失效，在去访问，就可以访问数据库更新这个key的值了



雪崩解决方案：

1.限流： 加锁，控制进入数据库请求数量

               private Lock lock  = new ReentrantLock();

               public String queryInfo(String key){

                       //step1：先从缓存中获取，获取不到，接着向下走

                      try{

                               //step2：加锁

                               lock.lock();

                              // step3：获取到锁后，再次从缓存中取数据

                             // 这样做的目的是，验证是否已经有其他请求已经查询到数据，并放入缓存中去了

                             // step4：到数据库中查询

                            // step5 : 查询的结果放入缓存 

                      }finally{

                         // step6: 解锁

                         lock.unlock();

                      }

             }

           

         这种方案的缺点：

                        1) 线程阻塞，导致用户体验不好

                        2) 加锁的粒度太大，对所有进入到这个方法的请求加锁，即所有的查询都被一把锁锁住



   2.服务降级 ：把锁的粒度变小，使用 ConcurrentHashMap加锁

|   |
| - |
| private Map&lt;String,String&gt; lockMap = new ConcurrentHashMap&lt;&gt;();<br>public String queryInfo(String key){<br>     //step1：先从缓存中获取，获取不到，接着向下走<br>    boolean lock = false;<br>    try{<br>        //step2:类似加锁<br>        lock = lockMap.putIfAbsent(key,"lock") == null;<br>        //拿到锁的线程，负责更新缓存，其他请求读取备份缓存或者执行降级策略<br>        if(lock){<br>            //step3:继续从缓存中获取<br>            // 这样做的目的是，验证是否已经有其他请求已经查询到数据，并放入缓存中去了<br>           // step4：到数据库中查询<br>           // step5 : 查询的结果放入缓存 ，包括备份缓存<br>        }else{<br>            //服务降级策略<br>            // 策略1：从备份缓存中获取<br>            // 策略2：返回一个固定值<br>        }<br>    }finally {<br>        // 最后解锁：<br>        lockMap.remove(key);<br>    }<br>} |


   

    优点：线程不阻塞，用户体验好

    缺点：数据不一致，缓存维护复杂

 

3.写定时任务去刷新更新热点缓存







缓存穿透

缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法查询出结果，因此也不会写入到缓存中，这将会导致每个查询都会去请求数据库，造成缓存穿透；



缓存穿透解决方案

布隆过滤

对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；

![](D:/download/youdaonote-pull-master/data/Technology/问题及总结/images/6D608F2AE884425F89C76FDA5CB872CB007FyU7Tgy1g1uzmo1u6ij30a00ayjri.jpg)

缓存空对象

当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；

![](https://gitee.com/hxc8/images7/raw/master/img/202407190802660.jpg)

但是这种方法会存在两个问题：

1. 如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；

1. 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。

比较

![](https://gitee.com/hxc8/images7/raw/master/img/202407190802921.jpg)

缓存雪崩

缓存雪崩是指，由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。

![](https://gitee.com/hxc8/images7/raw/master/img/202407190802236.jpg)

解决方案

保证缓存层服务高可用性

即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，比如 Redis Sentinel 和 Redis Cluster 都实现了高可用。 

依赖隔离组件为后端限流并降级

在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

数据预热

可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

缓存并发

缓存并发是指，高并发场景下同时大量查询过期的key值、最后查询数据库将缓存结果回写到缓存、造成数据库压力过大

分布式锁

在缓存更新或者过期的情况下，先获取锁，在进行更新或者从数据库中获取数据后，再释放锁，需要一定的时间等待，就可以从缓存中继续获取数据。


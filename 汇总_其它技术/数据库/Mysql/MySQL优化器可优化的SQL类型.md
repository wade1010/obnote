



![](https://gitee.com/hxc8/images7/raw/master/img/202407190813166.jpg)

1、重新定义表的关联7顺序



优化器会根据统计信息来决定表的关联顺序





2、将外连接转化成内连接



3、使用等价变换规则



（5 = 5 and a > 5）被改写成a>5





![](https://gitee.com/hxc8/images7/raw/master/img/202407190813478.jpg)



查询优化器还可以利用索引和列是否为空来对count()、min()和max()这样的聚合函数来进行优化，

前面我们所说的B-tree索引是按顺序来进行存储的，所以呢要找到一列的最小值，那只需要查询对应的B-tree索引最左边的记录呢就可以了，因此呢MySQL可以直接获取索引的第一行记录。知道这一列的最小值是什么了，在优化器生成执行计划的时候呢就可以利用到这一点。

类似地，若要找到一个列的最大值，也可以读取B-tree索引的最后一个记录，如果MySQL使用的这种优化呢，我们会在这个查询计划中呢看到下图的提示信息

![](https://gitee.com/hxc8/images7/raw/master/img/202407190813057.jpg)

那么从字面意思呢可以看出，他表示优化器呢已经从执行计划中的移除了该表。并以一个常数呢取而代之。



类似没有任何where条件的count查询，通常也可以使用存储引擎来提供一些优化。例如myisam的统计信息中呢，维护了一个变量来存放数据表的行数。但是innodb的统计信息是不准确的，索引就不能使用这种方式来优化了



那么接下来呢查询优化器还可以判断where从保存从句中保存的表达式是否可以转换成一个常数，如果可以的话呢就会把这个表达式作为一个常数来进行优化处理。



![](https://gitee.com/hxc8/images7/raw/master/img/202407190813651.jpg)





![](https://gitee.com/hxc8/images7/raw/master/img/202407190813298.jpg)



![](https://gitee.com/hxc8/images7/raw/master/img/202407190813582.jpg)
















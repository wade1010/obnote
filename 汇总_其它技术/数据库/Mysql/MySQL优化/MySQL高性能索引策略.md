0:对于innodb而言,因为节点下有数据文件,因此节点的分裂将会比较慢.

对于innodb的主键,尽量用整型,而且是递增的整型.

如果是无规律的数据,将会产生的页的分裂,影响速度.

 

索引覆盖:

索引覆盖是指 如果查询的列恰好是索引的一部分,那么查询只需要在索引文件上进行,不需要回行到磁盘再找数据.

这种查询速度非常快,称为”索引覆盖”

 

理想的索引

1:查询频繁 2:区分度高  3:长度小  4: 尽量能覆盖常用查询字段.

 

 

1: 索引长度直接影响索引文件的大小,影响增删改的速度,并间接影响查询速度(占用内存多).

 

针对列中的值,从左往右截取部分,来建索引

1: 截的越短, 重复度越高,区分度越小, 索引效果越不好

2: 截的越长, 重复度越低,区分度越高, 索引效果越好,但带来的影响也越大--增删改变慢,并间影响查询速度.

 

所以, 我们要在  区分度 + 长度  两者上,取得一个平衡.

 

惯用手法: 截取不同长度,并测试其区分度,

 

mysql> select count(distinct left(word,6))/count(*) from dict;

+---------------------------------------+

| count(distinct left(word,6))/count(*) |

+---------------------------------------+

|                                0.9992 |

+---------------------------------------+

1 row in set (0.30 sec)

 

 

 

![](https://gitee.com/hxc8/images7/raw/master/img/202407190811795.jpg)

 

 

对于一般的系统应用: 区别度能达到0.1,索引的性能就可以接受.

 



2:对于左前缀不易区分的列 ,建立索引的技巧

如 url列

http://www.baidu.com

列的前11个字符都是一样的,不易区分, 可以用如下2个办法来解决

1: 把列内容倒过来存储,并建立索引

Moc.udiab.www//:ptth

这样左前缀区分度大,

 

2: 伪hash索引效果

同时存 url_hash列
1. 客户端发送SQL请求给服务器

1. 服务器检查是否可以在查询缓存中命中该SQL，命中则直接返回结果

1. 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划

1. 根据执行计划，调用存储引擎API来查询数据

1. 将结果返回给客户端



第2步和第5步都有可能对查询的速度产生影响







查询缓存对SQL性能的影响



优先检查这个查询是否命中查询缓存中的数据，这个检查是通过一个对大小写敏感的哈希查找实现的，hash查找只能进行全值匹配，所以请求的SQL和缓存的SQL有一个字节的不同都不会命中，不命中就会进入到下一个步骤。



如果命中了缓存，则MySQL会检查用户权限，但是无需解析查询的SQL语句，如果权限没有问题，则直接返回结果。



事实上要从缓存中直接返回结果，并不容易。查询SQL和缓存SQL要完全一致，即使只有一个字节不同也不行。



另外，如缓存中的结果是正确的，我们必须要每次缓存中SQL涉及的表，一旦更新都要对缓存结果进行刷新，也就是说同一个SQL，即使是同一个表中的查询中不涉及字段被更新了，那么下次再查询这个SQL，同样无法在缓存中命中。

此外每次在缓存中检查SQL是否命中时都要对缓存进行加锁，所以呢对读写比较频繁的系统来说，查询缓存很可能降低查询效率，所以在这种情况下建议大家不要使用查询缓存



![](https://gitee.com/hxc8/images7/raw/master/img/202407190813182.jpg)





query_cache_type 设置查询缓存是否可用 默认是off



可选值  on  off   demand



DEMAND表示只有在查询语句中

使用SQL_ CACHE和SQL _NO_ _CACHE

来控制是否需要缓存







query_cache_size  设置查询缓存的内存大小



query_cache_limit  设置查询缓存可用存储的最大值



on的情况下，如果预先知道查询结果很大，可以在SQL加上SQL_NO_CACHE可以提高效率





如果没命中缓存则进行下一步骤



![](https://gitee.com/hxc8/images7/raw/master/img/202407190813183.jpg)



![](https://gitee.com/hxc8/images7/raw/master/img/202407190813571.jpg)



![](D:/download/youdaonote-pull-master/data/Technology/数据库/Mysql/images/1B752246F0AC488F91B79932E38913F6image.png)



一条查询可能有很多种执行方式，查询优化器会对每一个查询可以用到的索引的统计信息来进行比较，以此来找到成本最低的一种方式来生成执行计划，如果可以使用的索引太多就会增加查询优化器生成查询计划的成本。

有很多种因素都会造成MySQL的查询优化器生成的查询计划是错误的。那有哪些因素呢？



统计信息不准确(有的存储引擎提供的准确有的不准确，innodb提供的行数信息，抽样数据估算出来的值。)





第二点呢是执行计划中的成本估算呢并不等于实际的执行计划的成本，因此呢即使统计信息是完全精确的，优化器给出的执行计划呢也可能并不是最优的。例如一个查询呢可以通过两种执行计划来完成，其中一种比另一种需要读取更多的页面。如果按照成本选择的话，MySQL查询优化器肯定会选择一种读取页面更少的那种执行计划。看上去他并没有什么问题，但是如果那个读取页面少的执行计划需要进行的是一些随机读取。而读取页面多的执行计划所需要进行是顺序读取，并且大部分页面已在内存中了。这样看来呢，使用读取页面更多的那种执行计划呢，显然来说成本会更低，但是遗憾的是MySQL并不知道这些。也就是说，貌似要去了服务器并不知道哪些页面在内存中哪些页面能在磁盘上。这些呢需要顺序读取，以及哪些页面需要顺序读取，哪些页面的需要随机读取。所以呢这也就造成了执行计划的不准确的一个因素。

![](https://gitee.com/hxc8/images7/raw/master/img/202407190813469.jpg)



MySQL查询优化器呢所认为的最优的进行计划了。可能跟我们所认为的最优计划的也是不一样的，我们可能希望呢SQL执行的时间的尽可能的短。但是MySQL只是基于其成本模型来选择最优的执行计划，而有些时候呢，这并不是一种最快的执行计划。



其他因素如下



从不会考虑其他的地方的查询。这可能会影响当前查询的速度，并发查询的可能会涉及到一些锁的一些因素呢，但是MySQL的优化性能并不会考虑这些。



而且MySQL也不是任何时候呢都是基于成本来进行优化的，有时候呢也会基于一些固定的规则。例如，如果查询中存在这种前文索引搜索条件的话，再存在全文索引的这个表的时候呢就会使用全文索引查找，即使有时候使用别的索引和条件组合呢，对于使用全文索引更快，那么MySQL仍然会使用全文索引而不会使用其他的索引来进行查找。



那接下来呢，MySQL不会考虑不受其控制的成本的，例如执行存储过程或者是用户自定义函数的成本都不在MySQL查询优化器考虑范围之内



![](https://gitee.com/hxc8/images7/raw/master/img/202407190813044.jpg)



![](https://gitee.com/hxc8/images7/raw/master/img/202407190813065.jpg)


























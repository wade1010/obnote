LSM树其核心思想是充分了利用了，磁盘批量的顺序写要远比随机写性能高出很多

写非常简单高效，但其缺点是对读取特别是随机读很不友好

Hbase，Cassandra，Leveldb，RocksDB，MongoDB，TiDB等



其优点是减少了空间放大，但缺点是合并时会造成严重的写放大问题



![](https://gitee.com/hxc8/images8/raw/master/img/202407191057962.jpg)



LSM（Log-Structured Merge-Tree）的设计思路是将所有的写操作追加到一个日志中，而不是直接在原有的数据结构中进行插入或更新。这样做的好处是可以最大化磁盘带宽，减少随机I/O的次数，从而提高吞吐量。同时，由于日志的顺序写入特性，可以将相同的键值写入到一起，方便后续的合并操作。

LSM树的具体实现包括以下几个部分：

1. 内存缓存：LSM树的第一层是一个内存缓存，也称为MemTable。所有的写入操作首先被写入到内存中的MemTable中。当MemTable达到一定的大小时，就将其写入磁盘中。

1. 磁盘分段：将内存中的MemTable写入磁盘中会生成一个新的磁盘分段，也称为SSTable。SSTable是一种只读的数据结构，它包含了一组有序的键值对。SSTable还包含了一个索引，用于加速读取操作。

1. 合并操作：为了保持数据的一致性和可靠性，LSM树需要周期性地将多个SSTable进行合并。合并操作将多个SSTable合并成一个更大的SSTable。在合并操作期间，会将相同的键值进行合并，并保留最新的值。为了避免重复的键值，LSM树还需要使用一些技术，如Bloom Filter等。

1. 删除操作：为了删除键值对，LSM树需要进行两个步骤。首先，将要删除的键值对标记为已删除，称为Tombstone。其次，需要将Tombstone在后续的合并操作中删除。

LSM树的设计思路使其能够在大数据量的情况下快速处理写入操作，并具有高吞吐量和高并发性。同时，由于LSM树使用多个副本和WAL协议保证数据的可靠性和一致性，因此也适合用于存储重要的数据。



优点：

1. 高吞吐量：LSM树的写入性能很高，因为它将所有新的写入操作追加到磁盘的末尾。这种方法可以最大化磁盘带宽，减少随机I/O的次数，从而提高吞吐量。

1. 易于扩展：LSM树易于扩展，可以通过添加更多的磁盘进行容量扩展。此外，LSM树的读性能也可以通过添加更多的SSD缓存进行提高。

1. 高并发性：由于写入操作不会阻塞读操作，所以LSM树具有高并发性。此外，由于LSM树的每个分段都是独立的，因此多个读取操作可以并发地访问不同的分段。

1. 高可靠性：LSM树可以保证数据的可靠性。在写入操作期间，LSM树使用WAL（Write-Ahead Logging）协议将所有操作记录在日志中，以防止数据丢失。在每个分段中，LSM树使用多个副本来保护数据免受磁盘损坏或错误的影响。

缺点：

1. 写放大：由于LSM树需要在磁盘上保留多个版本的数据，因此写放大是LSM树的一个缺点。每次写操作都会导致多个版本的数据被写入磁盘。

1. 读放大：在读取操作期间，LSM树需要在多个分段中搜索相同的键值。这可能导致读放大，因为每个分段都需要被搜索。为了缓解这个问题，LSM树使用了Bloom Filter来减少无效搜索。

1. 数据不一致：由于LSM树使用后台线程来合并多个分段，因此在读取操作期间可能会发生数据不一致的情况。这可能会导致读操作返回错误的结果。为了解决这个问题，LSM树需要使用一些技术来保证数据的一致性，例如读取时加锁或版本控制。

1. 复杂性高：LSM树的实现比较复杂，需要使用许多不同的技术来保证数据的一致性和可靠性。这使得LSM树的实现和调试都比较困难。




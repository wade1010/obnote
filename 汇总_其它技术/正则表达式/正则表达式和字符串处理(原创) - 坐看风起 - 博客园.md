第一章正则表达式概述

正则表达式(Regular Expression)起源于人类神经系统的研究。正则表达式的定义有以下几种：

l用某种模式去匹配一类字符串的公式，它主要是用来描述字符串匹配的工具。

l描述了一种字符串匹配的模式。可以用来检查字符串是否含有某种子串、将匹配的子串做替换或者从中取出符合某个条件的子串等。

l由普通字符(a-z)以及特殊字符（元字符）组成的文字模式，正则表达式作为一个模版，将某个字符模式与所搜索的字符串进行匹配。

l用于描述某些规则的的工具。这些规则经常用于处理字符串中的查找或替换字符串。也就是说正则表达式就是记录文本规则的代码。

l用一个字符串来描述一个特征，然后去验证另一个字符串是否符合这个特征。

以上这些定义其实也就是正则表达式的作用。

第二章正则表达式基础理论

这些理论将为编写正则表达式提供法则和规范，正则表达式主要包括以下基础理论：

l元字符

l字符串

l字符转义

l反义

l限定符

l替换

l分组

l反向引用

l零宽度断言

l匹配选项

l注释

l优先级顺序

l递归匹配

2．1 元字符

在正则表达式中，元字符（Metacharacter）是一类非常特殊的字符，它能够匹配一个位置或字符集合中的一个字符，如：、 \w等。根据功能，元字符可以分为两种类型：匹配位置的元字符和匹配字符的元字符。

2．1．1 匹配位置的元字符

包括：^、$、和\b。其中^（脱字符号）和$（美元符号）都匹配一个位置，分别匹配行的开始和结尾。比如，^string匹配以string开头的行，string$匹配以string结尾的行。^string$匹配以string开始和结尾的行。单个$匹配一个空行。单个^匹配任意行。\b匹配单词的开始和结尾，如：\bstr匹配以str开始的单词，但\b不匹配空格、标点符号或换行符号，所以，\bstr可以匹配string、string fomat等单词。\bstr正则表达式匹配的字符串必须以str开头，并且str以前是单词的分界处，但此正则表达式不能限定str之后的字符串形式。以下正则表达式匹配以ing结尾的字符串，如string、This is a string等

Ing\b

正则表达式ing\b匹配的字符串必须以ing结尾，并且ing后是分界符，以下正则表达式匹配一个完整的单词：\bstring\b。

2.1.2匹配字符的元字符

匹配字符的元字符有7个:.(点号)、\w、\W、、s\、\S、\d和\D。其中点号匹配除换行之外的任意字符；\w匹配单词字符（包括字母、汉字、下划线和数字）；\W匹配任意非单词字符、\s匹配任意的空白字符，如空格、制表符、换行等；\S匹配任意的非空白字符；\d匹配任意数字字符；\D匹配任意的非数字字符。如：

^.$匹配一个非空行，在该行中可以包含除了换行符以外的任意字符。

^\w$匹配一个非空行，并且该行中只能包含字母、数字、下划线和汉字中的任意字符。

\ba\w\w\w\w\w\w\\b匹配以字母a开头长度等于7的任意单词

\ba\w\w\w\d\d\d\D\b匹配以字母a开头后面有3个字符三个数字和1个非数字字符长度等于8的单词

2.2 字符类

字符类是一个字符集合，如果该字符集合中的任何一个字符被匹配，则它会找到该匹配项。字符类可以在[]（方括号）中定义。如：

[012345]可以匹配数字0到5中的任意一个。

可以匹配HTML标签中的H1到H6。

[Jj]ack可以匹配字符串Jack或jack。

但是，由于表达式[0123456789]书写非常不方便，连字符(-)便应用而生,[0-9]等价于[0123456789]。[a-z]匹配任何小写字母，[A-Z]匹配任意大写字母。如果要在字符类中包含连字符，则必须包含在第一位，如：[-a]表示表达式匹配-或者a。在字符类中如果^是字符类的第一个字符表示否定该字符串，也就是匹配该字符串外的任意字符，如：[^abc]匹配除了abc以外的任意字符，[^-]匹配除了连字符以外的任意字符，a[^b]匹配a之后不是b的字符串。

表2-1 常用的字符类

| 字符或表达式 | 说明 |
| - | - |
| \\w | 匹配单词字符(包括字母、数字、下划线和汉字) |
| \\W | 匹配任意的非单词字符(包括字母、数字、下划线和汉字) |
| \\s | 匹配任意的空白字符，如空格、制表符、换行符、中文全角空格等 |
| \\S | 匹配任意的非空白字符 |
| \\d | 匹配任意数字 |
| \\D | 匹配任意的非数字字符 |
| [abc] | 匹配字符集中的任何字符 |
| [^abc] | 匹配除了字符集中包含字符的任意字符 |
| [0-9a-z\_A-Z\_] | 匹配任何数字、字母、下划线。等同于\\w |
| \\p{name} | 匹配{name}指定的命名字符类中的任何字符 |
| \\P{name} | 匹配除了{name}指定的命名字符类中之外的任何字符 |
| . | 匹配除了换行符号之外的任意字符 |
| [^0-9a-zA-Z\_] | 等同于\\W |


2.3 字符转义

表2-2：常用的转义字符

| 表达式 | 可匹配 |
| - | - |
| \\r, \\n | 代表回车和换行符 |
| \\t | 制表符 |
| \\\\ | 代表 "\\" 本身 |


还有其他一些在后边章节中有特殊用处的标点符号，在前面加 "\" 后，就代表该符号本身。比如：^, $ 都有特殊意义，如果要想匹配字符串中 "^" 和 "$" 字符，则表达式就需要写成 "\^" 和 "\$"。

| 表达式 | 可匹配 |
| - | - |
| \\^ | 匹配 ^ 符号本身 |
| \\$ | 匹配 $ 符号本身 |
| \\. | 匹配小数点（.）本身 |


2.4 反义

在使用正则表达式时，如果需要匹配不在字符类指定的范围内的字符时，可以使用反义规则。其实我们已经使用过反义表达式，如\W、\S、\D、[^abc]等。常用的反义表如下：

表2-3：常用的反义表达式

| 字符或表达式 | 说明 |
| - | - |
| \\W | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \\S | 匹配任意不是空白符的字符 |
| \\D | 匹配任意非数字的字符 |
| \\B | 匹配不是单词开头或结束的位置 |
| [^x] | 匹配除了x以外的任意字符 |
| [^aeiou] | 匹配除了aeiou这几个字母以外的任意字符 |


2.4 限定符

正则表达式的元字符一次只能匹配一个位置或一个字符，如果需要匹配零个一个或多个字符时，则需要使用限定符。限定符用于指定允许特定字符或字符集自身重复出现的次数。如{n}表示出现n次；{n,}表示重复至少n次；{n,m}表示至少出现n次最

多m次。常用限定符如下表：

表2-4：常用限定符

| 字符 | 描述 |
| - | - |
| \* | 匹配前面的子表达式零次或多次。例如，zo\* 能匹配 "z" 以及 "zoo"。 \* 等价于{0,}。 |
| + | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ? | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。 |
| {n} | n是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,} | n是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o\*'。 |
| {n,m} | m和 n 均为非负整数，其中n &lt; em style='font-size:14px;font-style:italic;font-weight:400;font-family:宋体;color:\#494949;' &gt;m。最少匹配 n 次且最多匹配 m 次。刘， "o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |
| \*？ | 尽可能少的使用重复的第一个匹配 |
| +？ | 尽可能少的使用重复但至少使用一次 |
| ?? | 如果有可能使用零次重复或一次重复。 |
| {n}? | 等同于{n} |
| {n,}? | 尽可能少的使用重复但至少重复n次 |
| {n,m}? | 介于n次和m次之间，尽可能少的使用重复。 |


2.5 贪婪、惰性和支配性匹配

惰性匹配：先看字符串中的第一个字母是不是一个匹配，如果单独一个字符还不够就读入下一个字符，如果还没有发现匹配，就不断地从后续字符中读取，只道发现一个合适的匹配，然后开始下一次的匹配。

贪婪匹配：先看整个字符串是不是一个匹配，如果没有发现匹配，它去掉字符串中最后一个字符并再次尝试，如果还没有发现匹配，那么再次去掉最后一个字符，这个过程会一直重复直到发现一个匹配或字符串不剩一个字符为止。

支配性匹配：只尝试匹配整个字符串，如果整个字符串不能产生一个匹配，则不再进行尝试。

我们普通的字符类均是贪婪匹配，如果在字符类后加个问号(?)则表示懒惰匹配，要成为支配性匹配则在懒惰匹配后加个问号(?).

2.6替换

正则表达式0\d{2}-\d{8}和0\d{3}-\d{7}分别匹配区号为3位和4位的固定电话号码，如果需要同时匹配区号为3位和4位的固定电话号码，可以使用替换满足这一需求。最简单的替换是使用竖线(|)表示。以下表达式匹配了区号为3位号码为8位和区号为4位号码为7位的的电话号码，区号和号码均使用-连接，0\d{2}-\d{8}|0\d{3}-\d{7}

表2-5 常用替换

| 字符或表达式 | 说明 |
| - | - |
| | | 匹配竖线(|)左侧或右侧 |
| (?(表达式)yes|no) | 表达式要么与yes部分匹配要么与no部分匹配，其中no部分可以省略。 |
| （？（name）yes|no） | 以name命名的字符串要么与yas部分匹配，要么与no部分pp，其中no部分可以省略 |


2.7 分组

分组又称为子表达式，即把一个正则表达式的全部或部分分成一个或多个组。其中分组使用圆括号()，分组后把圆括号中的表达式看做一个整体来处理，比如:（abc）{1，2}表示abc出现一次或两次的字符串，其中把abc看做一个整体来进行匹配。

2.8 后向引用

当一个正则表达式被分组后，每一个组将自动被赋予一个组号，该组号可以代表该组的表达式。其中，组号的编制规则为：从左到右，以分组的左括号为标志，第一个组号为1，第二个分组号为2，以此类推。如：(A?(B?(C?)))将产生3个组号，第一组为：(A?(B?(C?)))；第二组为： (B?(C?))；第三组为:(C?)。

反向引用提供了查找重复字符组的方便方法，反向引用可以使用数字命名（默认名称）的组号，也可以使用指定命名的组号。比如：\b(\w)\1\b匹配两个字符一样的单词，此表达式和\b(\w)\w\b不一样，后者两个字符可以不一样。再看，\b(\w)(\d)\1\2\b，匹配一个字符和一个数字然后重复字符和数字。\b\w*(\w+)\1\b匹配以至少两个字符一样结尾的单词。\b(\w+)\b\s+\1\b此正则表达式匹配的具体过程如下：

a.表达式\b(\w+)\b匹配一个单词并且单词的长度至少为1

b.表达式\s+匹配一个或多个空白字符

c.表达式\1将重复子表达式(\w+)匹配的内容，及匹配重复的单词

d.匹配单词的结束位置。

分组不仅可以使用数字作为组号，还可以使用自定义名称作为组号。以下两个正则表达式都是将分组后的子表达式\w+命名为word.

(?\w+)

(?’word’\w+)

因此\b(\w+)\b\s+\1\b和以下正则表达式是等价的，都匹配重复的单词：

\b(?\w+)\b\s+\k\b

表2-5 后向引用说明表

| 表达式 | 说明 |
| - | - |
| \\数字 | 使用数字命名的后向引用 |
| \\k | 使用指定命名的后向引用 |


表2-6 常用分组说明

| 字符 | 说明 |
| - | - |
| (expression) | 匹配字符串expression,并将匹配的文本保存到自动命名的组里 |
| (? expression) | 匹配字符串expression,并将匹配的文本保存到以name命名的变量中，该名称不能包含标点符号，不能以数字开头。 |
| (?:expression) | 匹配字符串expression,不保存匹配的文本，也不分配组号 |
| (?!expression) | 匹配后面不是字符串expression的位置 |
| (?=expression) | 匹配字符串expression前面的位置 |
| (?&lt; expressionp&gt; | 匹配字符串expression后面的位置 |
| (? | 匹配前面不是字符串expression的位置 |
| (?&lt;expression) | 只匹配expression一次 |


2.9 零宽度断言

元字符^、\b、$都匹配一个位置，并且这个位置满足一定条件。在此把满足一个条件称为断言或零宽度断言。正则表达式中零宽度断言说明如下表：

表2-6 零宽度断言

| 字符（断言） | 说明 |
| - | - |
| ^ | 匹配行的开始位置 |
| $ | 匹配行的结束位置 |
| \\A | 匹配必须出现在字符串的开头 |
| \\Z | 匹配必须出现在字符串的结尾或字符串结尾处的换行符(\\n)前 |
| \\z | 匹配必须出现在字符串的结尾 |
| \\G | 匹配必须出现在上个匹配结束的地方 |
| \\b | 匹配单词的开始或结束的位置 |
| \\B | 匹配不是单词的开始或结束的位置 |


表达式(?=expression)、(?!expression)、(?< expressionspan style='font-size:14px;font-style:normal;font-weight:400;font-family:宋体;color:#494949;' >、和(?都是匹配一个位置。下面将详细介绍表达式(?=expression)和(?< expressionspan style='font-size:14px;font-style:normal;font-weight:400;font-family:宋体;color:#494949;' >。

(?=expression)又称为零宽度正预测先行断言，它断言自身位置的前面能够匹配表达式expression。以下正则表达式匹配以ed结尾的单词的前面部分：\b\w+(?=ed\b)。

(?< expressionspan style='font-size:14px;font-style:normal;font-weight:400;font-family:宋体;color:#494949;' >又称为零宽度正回顾后发断言，它断言自身位置的后面能够匹配表达式expression，以下正则表达式匹配以an开头的单词的后面部分，即匹配单词除了字符串an之外的部分：(?< banwbp>

2.10 负向零宽度断言

零宽度断言只能指定或匹配一个位置，而负向零宽度断言与零宽度断言正好相反，它能指定或匹配不是一个位置，即所说的反义。特别是在匹配字符串中不包含指定的字符时，负向零宽度断言特别有用，比如要匹配断言字符a之后不能是字符b的表达式为：

\b\w*a(?!b)\w*\b

因此该表达式匹配一个单词，并且这个包含字符a并且a后面不是紧随着b

表达式(?!expression)称为负向零宽度断言，它断言自身位置后不能包含expression。以下正则表达式匹配一个z字符串，字符串前三位为字符并且后边不是紧随着数字：\b\w{3} (?!\d+)；表达式(?称为零宽度回顾后发断言，它断言自身位置的前面不能匹配字符串expression。以下表达式匹配不以数字开头、并且字符串中只包含大写字母、小写字母或下划线。

(?

2.11匹配选项

匹配选项可以指定正则表达式匹配中的行为，如忽略大小写、处理多行、处理单行、从右到左开始匹配等。常用的匹配选项如下：

表2-7 常用匹配选项

| RegexOptions枚举值 | 内联标志 | 简单说明 |
| - | - | - |
| ExplicitCapture | n | 只有定义了命名或编号的组才捕获 |
| IgnoreCase | i | 不区分大小写 |
| IgnorePatternWhitespace | x | 消除模式中的非转义空白并启用由\#标记的注释。 |
| MultiLine | m | 多行模式，其原理是修改了^和$的含义 |
| SingleLine | s | 单行模式，和MultiLine相对应 |


2.12 优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：

表2-8：优先级说明

| 运算符 | 说明 |
| - | - |
| \\ | 转义符 |
| (), (?:), (?=), [] | 括号和中括号 |
| \*, +, ?, {n}, {n,}, {n,m} | 限定符 |
| ^, $, \\anymetacharacter, anycharacter | 定位点和序列 |
| | | 替换 |


字符的优先级比替换运算符高，替换运算符允许“m|food”与“m”或“food”匹配。若要匹配“mood”或“food”，请使用括号创建子表达式，从而产生“(m|f)ood”。

2.12 递归匹配

递归匹配在匹配具有嵌套结构的字符串时特别有效。比如算术表达式((1+2)*(3+4))具有嵌套结构，如果要使用正则表达式检查该表达式是否正确，则可以使用递归匹配解决该问题。

这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。

有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\(.+\)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？

为了避免(和\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx aa< yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？

这里需要用到以下的语法构造：

- (?'group') 把捕获的内容命名为group,并压入堆栈(Stack)

- (?'-group') 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败

- (?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分

- (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个"group"，第二个就是从黑板上擦掉一个"group"，第三个就是看黑板上写的还有没有"group"，如果有就继续匹配yes部分，否则就匹配no部分。

我们需要做的是每碰到了左括号，就在压入一个"Open",每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。

< span>最外层的左括号

    [^<>]*                #最外层的左括号后面的不是括号的内容

    (

        (

            (?'Open'< span>碰到了左括号，在黑板上写一个"Open"

            [^<>]*       #匹配左括号后面的不是括号的内容

        )+

        (

            (?'-Open'<)   #碰到了右括号，擦掉一个"Open"

            [^<>]*        #匹配右括号后面不是括号的内容

        )+

    )*

    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败

<                         #最外层的右括号

平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的

标签：

]*<[^<>]*(((?'Open'

]*<)[^<>]*)+((?'-Open'

)[^<>]*)+)*(?(Open)(?!))

.
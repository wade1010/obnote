缓存层打包服务对OEOS端TIKV事务的影响做如下分析：



打包服务那里大概就是，读取需要打包的的数据列表或者所有文件的元数据，然后到各个服务器的磁盘上把文件读出来，然后合并压缩打成一个单独的大文件，然后传到数据节点（S3），传完后就会返回 新的locationID,storageID,offset等，

然后循环数据列表，通过TIKV_FULL_KEY、locationID和storageID 找到对应的元数据，把对应的版本上的locationID,storageID,offset等更新，就完成了一次打包流程。



如下两种情况情况：

1、没开多版本：

比如现在TBDL分区有个OS/T000/003/Data/LS/a.java

我重新put个a.java，

1.1、在我开启事务前，打包服务更新了a.java，没有影响；

1.2、在我开启事务到提交事务期间，打包服务更新了a.java。我这边就会提示写冲突，导致失败

1.3、在我开启事务后，打包服务更新，这时候找不到相应的文件，因为被挪到了TBDR分区。

 挪走后有两种办法：

1.3.1、打包服务发现找不到这个文件，就跳过，遗留问题就是S3那边就成了孤魂野鬼了，垃圾数据回收不掉，而且TBDR那里回收的时候在对应盘里找不到该文件，因为被打包到S3了

1.3.2、打包服务发现找不到这个文件，就去回收区找，因为我们的打包服务和回收服务是互斥的，所以肯定在回收区，更新回收区就行了



2、开启多版本。

如果打包区的文件是最新的，也就是在TBDL分区就会出现上面不开多版本时同样问题

如果打包区的文件不是最新的，应该就没事。应该没有其他地方改历史分区的数据。最多是挪到TBDR回收区,挪走也没事，挪走后两种处理办法如上。





总结下来，打包那里用不用事务都可能会导致OEOS这边TBDL分区元数据更新失败、



我想到的解决思路:

一、降低事务冲概率突法

打包服务分成历史分区和最新分区两个部分打包。

历史分区，随时都能打包。

最新分区，需要读取下当前最新数据(读取不会影响OEOS这边事务)

如果发现不存在(也就是被挪到了TBDR回收区，更新这个回收区即可)

如果存在，如果超过某个设定的时间段没更新过就认为该对象修改次数较少，可以直接更新该元数据。

也可以根据缓存盘容量阈值，打包不同 未更新时间段 的文件

如缓存盘容量剩余50%,就能打包10个小时没更新过的文件

如缓存盘容量剩余60%,就能打包9个小时没更新过的文件

..................

这个方法最终还是可能有冲突导致OEOS这边操作失败



二、OEOS启动协程打包法

打包服务打包历史分区TBDH时，直接打包

打包服务打包最新分区TBDL时，将一个全局变量置为true，并获打包key取写锁，然后再操作这个key

更新元数据那里判断全局变量为true，也需要操作key的写锁，获取不到就等待一段时间。

这个方法，打包频繁的话，需要多一个获取锁的操作，并发量会下降。



三、OEOS实时追加写法

大概思路流程图如下，具体细节未标明

![](https://gitee.com/hxc8/images6/raw/master/img/202407190006829.jpg)



下沉到S3后回头更新元数据，如果是TBDL分区的也需要获取写锁，避免事务冲突。
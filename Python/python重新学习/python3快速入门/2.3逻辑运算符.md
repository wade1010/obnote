我们一般用逻辑运算符时，左右两边的结果是True或者False，最后得到一个True或者False

但，有时逻辑运算符的左右两边不是True或者False，这种情况我们就需要小心一点

看下面的示例，猜猜看，结果是多少

```python
print(100 and 200)  # 输出什么呢？
print(100 and 100>50)  # 输出什么呢？
print(0 and 200)  # 输出什么呢？
print(0 and 100>50)  # 输出什么呢？复制Error复制成功...
```

运行结果：

```
200
True
0
0复制Error复制成功...
```

为什么呢？

答：想要搞懂这个问题，需要有2点

第1点：

Python中是有布尔类型的也就是True和False 用True表示真 用False表示假，而在一些其它编程语言中没有，例如C语言中是没有布尔类型的，因此C语言为了能够表示出真、假，就发明了一个规定，只要数字不是0 无论是正数还是负数 统统表示真，只要是0就表示假。

后来，虽然Python发明了True和False，但它依然保留了C语言中的这种开发者都已经习以为常的习惯，所以Python中也用

- 非0表示 真

- 0表示假

第2点：

我们知道and实现的是两边都是True最后结果才是True，否则是False，但是它有个隐藏的功能，

如果左边的表达式不是True那么右边根本不会执行，且将左侧的值当做最后结果

如果左边的表达式是True那么右边才会执行，且将右侧的值当做最后的结果

之所以有这个隐藏的功能是因为：and是与的功能，既然左侧已经为假了，也就没有必要看右边了，结果一定是假，只不过此时把左侧的结果当做最后结果而已

根据上述2点来看

print(100 and 200)，因为100不是0 所以and左边为真，接下来执行右边，此时将200当做最后的结果

print(100 and 100>50)，因为100不是0 所以为真，执行右边 100>50且将它的结果当做最后的结果，所以最后为True

print(0 and 200)，因为and左侧为0 所以为假，不会执行右边，且将左边的结果当做最后结果，所以最后为0

print(0 and 100>50)，原因与上一条一样，结果为0

有了前面and的额外经验，我们再看or时就简单多了

or的特殊规则如下:

- 如果左边为真，那么就把左边的值当做最后的结果

- 如果左边为假，那么就把右边的值当做最后的结果

or之所以有这样功能是因为：or是或的功能，既然左侧已经为真了，也就没有必要看右边了，结果一定是真，只不过此时把左侧的结果当做最后结果而已

来试试看，掌握了没有

```python
print(100 or 200)  # 输出什么呢？
print(100 or 100>50)  # 输出什么呢？
print(0 or 200)  # 输出什么呢？
print(0 or 100>50)  # 输出什么呢？复制Error复制成功...
```

运行结果如下：

```python
100
100
200
True复制Error复制成功...
```

原因不用我说了吧，如果真的还不知道为什么，那么我觉得你有必要把上面的知识好好再看一遍，只有知道为什么才是真的会了

| 逻辑运算符 | 表达式 | 描述 | 实例 | 
| -- | -- | -- | -- |
| and | x and y | 布尔"与"：如果 | True and False | 
| or | x or y | 布尔"或"：如果 | False or True | 
| not | not x | 布尔"非"：如果 | not True | 

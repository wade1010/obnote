什么是运行时？

运行时代表二进制文件中包含的由语言本身提供的代码，这些代码根据语言的不同可大可小，不过非汇编语言都会有一定数量的运行时代码。

通常，大家说一个语言“没有运行时”，是指这个语言的“运行时”很小。Rust、C都是几乎没有运行时的。

2024-2-6 17:43:53 补充,请看下面大的红色字体

通过上面的学习，我们知道在Python中，每个对象都保存了一个称为引用计数的整数值，来追踪到底有多少引用指向了这个对象。

无论何时，如果我们程序中的一个变量或其他对象引用了目标对象，Python将会增加这个计数值，而当程序停止使用这个对象，则Python会减少这个计数值。一旦计数值被减到零，Python将会释放这个对象以及回收相关内存空间。

从六十年代开始，计算机科学界就面临了一个严重的理论问题，那就是针对引用计数这种算法来说，如果一个数据结构引用了它自身，即如果这个数据结构是一个循环数据结构，那么某些引用计数值是肯定无法变成零的。

为了更好地理解这个问题，让我们举个例子。

下面的代码展示了一些上面我们所用到的节点类：

![](https://gitee.com/hxc8/images4/raw/master/img/202407172322082.jpg)

我们有一个"构造器"(在Python中叫做__init__)，在一个实例变量中存储一个单独的属性。在类定义之后我们创建两个节点，"ABC"以及"DEF"，在图中为左边的矩形框。两个节点的引用计数都被初始化为1，因为各有两个引用指向各个节点(n1和n2)。

现在，让我们在节点中定义两个附加的属性，next以及prev：

![](https://gitee.com/hxc8/images4/raw/master/img/202407172322388.jpg)

跟Ruby不同的是，Python中你可以在代码运行的时候动态定义实例变量或对象属性。这看起来似乎有点像Ruby缺失了某些有趣的魔法。

我们设置 n1.next 指向 n2，同时设置 n2.prev 指回 n1。

现在，我们的两个节点使用循环引用的方式构成了一个双向链表。同时请注意到 ABC 以及 DEF 的引用计数值已经增加到了2。

这里有两个指针指向了每个节点：首先是 n1 以及 n2，其次就是 next 以及 prev。

现在，假定我们的程序不再使用这两个节点了，我们将 n1 和 n2 都设置为None。

![](https://gitee.com/hxc8/images4/raw/master/img/202407172322613.jpg)

好了，Python会像往常一样将每个节点的引用计数减少到1。

正如Ruby使用一个链表(free list)来持续追踪未使用的、自由的对象一样，Python使用另一种不同的链表来持续追踪活跃的对象。而不将其称之为“活跃列表”，Python的内部C语言代码将其称为零代(Generation Zero)。

每次当你创建一个对象的时候，Python会将其加入零代链表：

![](https://gitee.com/hxc8/images4/raw/master/img/202407172322513.jpg)

从上边可以看到当我们创建ABC节点的时候，Python将其加入零代链表。请注意到这并不是一个真正的列表，并不能直接在你的代码中访问，**事实上这个链表是一个完全内部的Python运行时**。 相似的，当我们创建DEF节点的时候，Python将其加入同样的链表：

![](https://gitee.com/hxc8/images4/raw/master/img/202407172322664.jpg)

现在零代包含了两个节点对象。(他还将包含Python创建的每个其他值，与一些Python自己使用的内部值。)
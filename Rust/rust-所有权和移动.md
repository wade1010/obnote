# 18.所有权

因为变量要负责释放它们拥有的资源，所以**资源只能拥有一个所有者**。这也防止了资源的重复释放。注意并非所有变量都拥有资源（例如引用）。

在进行赋值（let a = b）或通过值来传递函数参数（foo(a)）的时候，资源的所有权（ownership）会发生转移。按照 Rust 的规范，这被称为资源的移动（move）。

在移动资源之后，原来的所有者不能再被使用，这可避免悬挂指针（dangling pointer）的产生。

内存分为两大类：**栈(stack)** 和 **堆(heap)**

它是一种 **后进先出** 的机制，类似我们日常的落盘子，只能一个一个向上方，然后从最上面拿一个盘子。一个变量要放到栈上，那么它的大小在编译时就要明确。i32 类型的变量，它就占用 4 个字节。Rust 中可以放到栈上的数据类型，他们的大小都是固定的。如果是字符串，在运行时才会赋值的变量，在编译期的时候大小是未知或不确定的。所以字符串类型存储在**堆**上。

用于编译时大小未知或不确定的，只有运行时才能确定的数据。在**堆**上存储一些动态类型的数据。**堆**是不受系统管理的，是用户自己管理的，也增加了内存溢出的风险。

所有权就是值一个东西归属谁。Rust 中一个变量对应一个值，变量就称为这个值得**所有者**。

|   | 


这句话的意思就是，”从 0 到 Go 语言微服务架构师” 这个值所在内存块由变量 name 所有。

Rust 中，只能由一个所有者，不允许两个同时指向同一块内存区域。变量必须指向不同的内存区域。

类似我们人类把一个东西送人或丢弃。

以下几种方式转让所有权：

1. 把一个变量赋值给另一个变量。

|   | 


- v1 拥有堆上数据的所有权。（每次只能有一个变量对堆上数据有所有权）

- v2=v1 v2 拥有了堆上数据的所有权。

- v1 已经没有对数据的所有权了，所以再使用 v1 会报错。

- 如果 Rust 检查到 2 个变量同时拥有堆上内存的所有权。会报错如上。

1. 把变量传递给函数参数。

|   | 


1. 函数中的返回值。

|   | 


所有权只会发生在堆上分配的数据，基础数据类型(整型，浮点型，布尔，字符)存储在栈上，所以没有所有权的概念。基础类型可以认为是值拷贝，在内存上另外的地方，存储和复制来的数据，然后让新的变量指向它。

|   | 


总结

赋值并不是唯一涉及移动的操作。值在作为参数传递或从函数返回时也会被移动: